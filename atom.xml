<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hong Xin</title>
  
  <subtitle>大肉丸</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-13T05:20:01.070Z</updated>
  <id>http://yoursite.com/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ubuntu16.04安装matlab</title>
    <link href="http://yoursite.com/posts/c730e2ef/"/>
    <id>http://yoursite.com/posts/c730e2ef/</id>
    <published>2018-03-13T05:20:00.000Z</published>
    <updated>2018-03-13T05:20:01.070Z</updated>
    
    <content type="html"><![CDATA[<p><strong>参考教程</strong>：<a href="http://lanbing510.info/2014/12/03/Linux-Matlab.html" target="_blank" rel="noopener">http://lanbing510.info/2014/12/03/Linux-Matlab.html</a><br>除此之外，Readme.txt这份文件也很重要！！！！</p><p><strong>matlab版本：</strong>R2014a(8.3)</p><p><strong>matlab下载：</strong><a href="https://pan.baidu.com/s/1qYJ9tNm#list/path=%2F" target="_blank" rel="noopener">https://pan.baidu.com/s/1qYJ9tNm#list/path=%2F</a></p><p><strong>matlab安装</strong><br>1.part1.rar 和 part2.rar 两个压缩包下载后，解压part1.rar即可得到 matlab 的iso镜像文件</p><blockquote><p>命令：rar x …part1.rar</p></blockquote><p>2.ubuntu使用iso文件，需先挂载，新建一个挂载文件夹</p><blockquote><p>sudo mkdir /usr/local/matlab2014</p></blockquote><p>2.挂载</p><blockquote><p>sudo mount -o loop /home/hongxin/Documents/matlab2014/MATHWORKS_R2014A.iso /usr/local/matlab2014<br>&ensp;<br><img src="http://hdoc.scau.edu.cn/Public/Uploads/2017-09-23/59c676ddc8650.png" alt=""></p></blockquote><p>3.解挂</p><blockquote><p>sudo umount /usr/local/matlab2014</p></blockquote><p>4.进入 /usr/local/matlab2014 文件夹，安装matlab</p><blockquote><p>sudo ./install</p></blockquote><p>5.执行命令后会弹出安装窗口<br>5.1 点击“使用文件安装密钥“<br>5.2 填写Readme.txt的密钥：12345-67890-12345-67890<br>5.3 一路默认<br>5.4 把crack的license文件拷贝到/usr/local<br>5.5 选择此 license 激活文件</p><p>6.破解<br>6.1 将crack文件夹下的libmwservices.so copy到 /usr/local/MATLAB/R2014a/bin/glnxa64</p><p>7.启动</p><blockquote><p>cd /usr/local/MATLAB/R2014a/bin<br>./matlab</p></blockquote><p>8.疑问<br>crack下的install.jar的作用：貌似是windows安装matlab用到的<br><a href="http://jingyan.baidu.com/article/eae07827a466a31fed548563.html" target="_blank" rel="noopener">http://jingyan.baidu.com/article/eae07827a466a31fed548563.html</a></p><p>9.将matlab执行路径添加到环境变量<br>打开环境配置文件</p><blockquote><p>sudo gedit /etc/profile</p></blockquote><p>添加以下内容<br><img src="http://hdoc.scau.edu.cn/Public/Uploads/2017-09-23/59c67bab8f89d.png" alt=""></p><blockquote><p>source /etc/profile</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;参考教程&lt;/strong&gt;：&lt;a href=&quot;http://lanbing510.info/2014/12/03/Linux-Matlab.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://lanbing510.info
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux防火墙与端口</title>
    <link href="http://yoursite.com/posts/a8ec0ca7/"/>
    <id>http://yoursite.com/posts/a8ec0ca7/</id>
    <published>2018-03-13T05:10:00.000Z</published>
    <updated>2018-03-13T05:10:40.820Z</updated>
    
    <content type="html"><![CDATA[<p>在Liunx中，主要由 iptables 来管理防火墙和各种端口。其实就是在写各种规则。</p><p>外网服务器和内网服务器的区别<br><strong>外网（广域网）：</strong> 由世界上的千万电脑组成的网络，所以别人可以访问你的外网服务器。比如183.232.231.172<br><strong>内网（局域网）：</strong> 由你自己的几台（个人），几十台（公司），几千台（学校）组成的网络，不在这个网络计算机的无法访问内网服务器。比如192.168.1.1<br><strong>网关：</strong> 外网与内网的中介，既有内网的IP地址，又有外网的IP地址，两个IP地址分别捆绑在不同的网卡上。所以网关既可以访问内网又可以访问内网。当内网服务器192.168.1.1 想访问外网服务器183.232.231.172时，就会把外网的IP发给网关，网关与外网取得联系后再把数据发回给内网。<br><strong>路由：</strong> 本质上就是网关。<br>DNS: （Domain Name System，域名系统）因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）</p><p>参考<br><a href="http://blog.csdn.net/w124374860/article/details/52641851" target="_blank" rel="noopener">http://blog.csdn.net/w124374860/article/details/52641851</a><br><a href="https://zhidao.baidu.com/question/1050628014291855339.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/1050628014291855339.html</a><br><a href="https://www.cnblogs.com/keyi/p/5948302.html" target="_blank" rel="noopener">https://www.cnblogs.com/keyi/p/5948302.html</a></p><p>端口映射<br>端口映射就是将外网主机的IP地址的一个端口映射到内网中一台机器，提供相应的服务。当用户访问该IP的这个端口时，服务器自动将请求映射到对应局域网内部的机器上。这样做可以避免全部服务器都暴露在外网中，不容易受到入侵。</p><p>在Linux中，端口映射常用 iptables 这个工具（其实是我只知道这个工具），关于这个工具的用法，可以看下面这篇文章。<br><a href="http://www.linuxidc.com/Linux/2016-09/134832.htm" target="_blank" rel="noopener">iptables超全详解</a></p><p>关于具体步骤参考下面的文章<br><a href="http://blog.csdn.net/gsls200808/article/details/50364104" target="_blank" rel="noopener">Linux下配置iptables实现外网访问内网KMS服务器</a><br><a href="http://blog.csdn.net/u013014606/article/details/76636970" target="_blank" rel="noopener">Centos6.5下端口映射操作</a></p><p>端口映射涉及的文件<br>/etc/rc.d/init.d :<br>rc.d = runlevel control directory<br>大多数的Linux 发行版本中，启动脚本都被放在/etc/rc.d/init.d。这些脚本被ln 命令来连接到 /etc/rc.d/rcn.d 目录。(这里的n 就是运行级0-6)<br>例如/etc/rc.d/rc2.d 下面的S10network 就是连接到/etc/rc.d/init.d下的network 脚本的。<br><a href="http://blog.csdn.net/wy19910326/article/details/7355013" target="_blank" rel="noopener">http://blog.csdn.net/wy19910326/article/details/7355013</a></p><p>/etc/sysconfig/iptables:<br><a href="https://jingyan.baidu.com/article/f96699bbe90f8e894e3c1bda.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/f96699bbe90f8e894e3c1bda.html</a></p><p>/etc/sysctl.conf:</p><p>&ensp;<br>主机名与IP<br>/etc/hosts :主机名和IP配置文件, 记录主机名与IP的对应关系。<br>打开后，一般可以看到两行，其中  127.0.0.1 表示ipv4的本机地址，而::1表示的时ipv6的本机地址<br><img src="http://hdoc.scau.edu.cn/Public/Uploads/2018-01-29/5a6f29f5a8932.png" alt=""></p><p>查看主机名</p><blockquote><p>hostname # 第一种<br>uname -n # 第二种，uname用来输出系统信息，uname –help 查看更多信息</p></blockquote><p>参考<br><a href="http://blog.csdn.net/xiaoshubiao/article/details/17283649" target="_blank" rel="noopener">http://blog.csdn.net/xiaoshubiao/article/details/17283649</a></p><p>防火墙<br><a href="https://www.awaimai.com/1650.html" target="_blank" rel="noopener">https://www.awaimai.com/1650.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Liunx中，主要由 iptables 来管理防火墙和各种端口。其实就是在写各种规则。&lt;/p&gt;
&lt;p&gt;外网服务器和内网服务器的区别&lt;br&gt;&lt;strong&gt;外网（广域网）：&lt;/strong&gt; 由世界上的千万电脑组成的网络，所以别人可以访问你的外网服务器。比如183.232.
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Centos7装机总结</title>
    <link href="http://yoursite.com/posts/1e7d71dd/"/>
    <id>http://yoursite.com/posts/1e7d71dd/</id>
    <published>2018-03-13T05:08:00.000Z</published>
    <updated>2018-03-13T05:08:42.526Z</updated>
    
    <content type="html"><![CDATA[<p>装机过程图文版（记得联网，装桌面可以看下面的装桌面教程）<br><a href="http://blog.csdn.net/panda_52panda/article/details/73770146" target="_blank" rel="noopener">http://blog.csdn.net/panda_52panda/article/details/73770146</a></p><p>yum 和 rpm区别<br><a href="https://zhidao.baidu.com/question/1690520549857824868.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/1690520549857824868.html</a></p><p>装桌面：<br><a href="https://www.cnblogs.com/c-xiaohai/p/6509641.html" target="_blank" rel="noopener">https://www.cnblogs.com/c-xiaohai/p/6509641.html</a></p><p>ln命令解释<br><a href="http://man.linuxde.net/ln" target="_blank" rel="noopener">http://man.linuxde.net/ln</a></p><p>桌面定制（从文章的第三步开始）<br>总参考文章： <a href="http://m.blog.csdn.net/panda_52panda/article/details/73770146" target="_blank" rel="noopener">http://m.blog.csdn.net/panda_52panda/article/details/73770146</a></p><blockquote><p>第一步<br>sudo yum install -y epel-release<br>sudo yum -y install liberation-mono-fonts<br>sudo yum  -y install gnome-menus<br>sudo yum -y install gnome-tweak-tool<br>sudo yum -y install gnome-shell   # 教程写漏了 install<br>sudo yum -y install gnome-shell-extension-*   # 这里教程也写错了</p></blockquote><p>第二步装扩展工具，推荐下面几个：<br>链接: <a href="https://pan.baidu.com/s/1nwM4i1b" target="_blank" rel="noopener">https://pan.baidu.com/s/1nwM4i1b</a> 密码: pnt5<br>Dash To Dock : Dock图标栏<br>Dynamic Top Bar: 顶栏透明效果<br>dynamic-panel-transparency ：透明化顶部状态栏<br>nohotcorner: 禁止左上角的热键<br><img src="http://hdoc.scau.edu.cn/Public/Uploads/2018-01-22/5a65f4874e1f2.png" alt=""><br><img src="http://hdoc.scau.edu.cn/Public/Uploads/2018-01-22/5a65f491815b3.png" alt=""></p><p>第三步，隐藏顶部栏和底部栏（隐藏顶部栏貌似输入法会失效）<br><a href="http://www.cnblogs.com/pinnsvin/p/5471479.html" target="_blank" rel="noopener">http://www.cnblogs.com/pinnsvin/p/5471479.html</a></p><p>桌面定制的其他参考文章<br><a href="http://blog.csdn.net/hobohero/article/details/54381552" target="_blank" rel="noopener">http://blog.csdn.net/hobohero/article/details/54381552</a></p><p>装chrome浏览器<br><a href="http://blog.csdn.net/u010472499/article/details/72327963" target="_blank" rel="noopener">http://blog.csdn.net/u010472499/article/details/72327963</a></p><p>将用户xxx加入sudoers组（如果在装机过程将xxx设置为管理员就不用）<br><a href="http://blog.csdn.net/swnjut/article/details/61199951" target="_blank" rel="noopener">http://blog.csdn.net/swnjut/article/details/61199951</a></p><p>sudo 执行命令免密码</p><blockquote><p>xxx    ALL=(ALL)    NOPASSWD: ALL</p></blockquote><p>google科学上网<br>先安装python3<br><a href="http://baijiahao.baidu.com/s?id=1580087400169490317&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">http://baijiahao.baidu.com/s?id=1580087400169490317&amp;wfr=spider&amp;for=pc</a></p><blockquote><p>yum install -y <a href="https://centos7.iuscommunity.org/ius-release.rpm" target="_blank" rel="noopener">https://centos7.iuscommunity.org/ius-release.rpm</a><br>yum update<br>yum install -y python35u python35u-libs python35u-devel python35u-pip<br>&ensp;<br># 安装好后更改执行程序的名字，便于敲命令<br>cd /usr/bin<br>sudo ln -s pip3.5 pip3<br>sudo ln -s python3.5 python3</p></blockquote><p>(如果没有 ius-release.rpm，可在这里下载<br>链接：<a href="https://pan.baidu.com/s/1gfTRGbD" target="_blank" rel="noopener">https://pan.baidu.com/s/1gfTRGbD</a> 密码：g80h )</p><p>安装shadowsock<br><a href="http://blog.csdn.net/u013309540/article/details/74330305" target="_blank" rel="noopener">http://blog.csdn.net/u013309540/article/details/74330305</a> (要将ssserver 换成 sslocal)<br><a href="http://blog.csdn.net/onlyellow/article/details/52021429" target="_blank" rel="noopener">http://blog.csdn.net/onlyellow/article/details/52021429</a></p><p>centos7 创建服务<br><a href="http://blog.csdn.net/u013309540/article/details/74330305" target="_blank" rel="noopener">http://blog.csdn.net/u013309540/article/details/74330305</a></p><p>更换镜像源(centos + PyPI)<br>centos <a href="https://mirrors.scau.edu.cn/mirrors-help/centos.html" target="_blank" rel="noopener">https://mirrors.scau.edu.cn/mirrors-help/centos.html</a><br>PyPI: 更换 pip 镜像源需先切换到 root 用户下，因为你安装包的时候是用 root 用户执行的</p><p>无法挂载ntfs磁盘</p><blockquote><p>sudo yum -y install ntfs-3g<br>安装好再点击磁盘即可打开</p></blockquote><p>开机自动挂载<br><a href="http://www.linuxidc.com/Linux/2014-11/109226.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2014-11/109226.htm</a></p><p>安装pycharm<br>1 下载安装包并解压<br>2  cd pycharm-community-2016.3.3/bin<br>3 sudo vim pycharm.sh<br>4 在Run the IDE 上面添加 三条 export 语句 (解决无法输入中文，pycharm版本可能要低一点，我用的是2016.3.3)<br><img src="http://hdoc.scau.edu.cn/Public/Uploads/2018-01-23/5a660fd69dde4.png" alt=""><br>5 运行 pycharm.sh</p><p>安装gcc</p><blockquote><p>sudo yum install gcc<br><a href="http://www.linuxidc.com/Linux/2017-03/142319.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2017-03/142319.htm</a></p></blockquote><p>安装git</p><blockquote><p>yum install git</p></blockquote><p>redis</p><blockquote><p>sudo yum install redis -y</p></blockquote><p>安装锐捷mentohust<br><a href="http://m.blog.csdn.net/DAMN_damn/article/details/57639118" target="_blank" rel="noopener">http://m.blog.csdn.net/DAMN_damn/article/details/57639118</a></p><p>安装shutter<br><a href="https://baijiahao.baidu.com/s?id=1572193682556704&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1572193682556704&amp;wfr=spider&amp;for=pc</a></p><p>安装smplayer<br>必须先安装nux-dextop-release-0-5.el7.nux.noarch.rpm</p><blockquote><p>yum install smplayer</p></blockquote><p>禁用SELinux<br><a href="http://blog.51cto.com/bguncle/957315" target="_blank" rel="noopener">http://blog.51cto.com/bguncle/957315</a></p><p>配置弹出终端的快捷键<br><img src="http://hdoc.scau.edu.cn/Public/Uploads/2018-01-23/5a6695a9c18cb.png" alt=""></p><p>&ensp;<br>配置终端的颜色<br><img src="http://hdoc.scau.edu.cn/Public/Uploads/2018-01-23/5a669698ea74a.png" alt=""></p><p>centos 备份与还原（tar 备份）<br><a href="http://blog.csdn.net/yuanfang_way/article/details/54383616" target="_blank" rel="noopener">http://blog.csdn.net/yuanfang_way/article/details/54383616</a><br><a href="http://blog.csdn.net/tham_/article/details/50402109" target="_blank" rel="noopener">http://blog.csdn.net/tham_/article/details/50402109</a><br><img src="http://hdoc.scau.edu.cn/Public/Uploads/2018-01-23/5a66b9fd1a77e.png" alt=""></p><p>终端ssh连接服务器，空闲时间自动断开连接 的解决办法<br><a href="http://blog.csdn.net/sandyloo/article/details/74979817" target="_blank" rel="noopener">http://blog.csdn.net/sandyloo/article/details/74979817</a></p><p>装wps<br><img src="http://hdoc.scau.edu.cn/Public/Uploads/2018-01-28/5a6d89a508aeb.png" alt=""></p><blockquote><p>sudo cp mtextra.ttf wingding.ttf symbol.ttf WINGDNG2.ttf WINGDNG3.ttf WEBDINGS.TTF  /usr/share/fonts</p></blockquote><p>装libreoffice<br><a href="http://blog.csdn.net/fk002008/article/details/50378154" target="_blank" rel="noopener">http://blog.csdn.net/fk002008/article/details/50378154</a></p><p>下载：<a href="http://mirrors.ustc.edu.cn/tdf/libreoffice/stable/" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/tdf/libreoffice/stable/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;装机过程图文版（记得联网，装桌面可以看下面的装桌面教程）&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/panda_52panda/article/details/73770146&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>解决Ubuntu16.04和win10时间不同步</title>
    <link href="http://yoursite.com/posts/3c93276/"/>
    <id>http://yoursite.com/posts/3c93276/</id>
    <published>2018-03-13T05:01:00.000Z</published>
    <updated>2018-03-13T05:07:48.938Z</updated>
    
    <content type="html"><![CDATA[<p>先在ubuntu下更新一下时间，确保时间无误：</p><p>sudo apt-get install ntpdate<br>sudo ntpdate time.windows.com</p><p>&ensp;<br>在ntpdate.com 这一步遇到no server suitable for synchronization found<br>运行命令：sudo ntpdate -buv 1.us.pool.ntp.org</p><p><img src="http://hdoc.scau.edu.cn/Public/Uploads/2017-07-12/596627b1b4892.png" alt=""></p><p>&ensp;<br>然后将时间更新到硬件上：<br>sudo hwclock –localtime –systohc(是两个小横，不是一个大横)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先在ubuntu下更新一下时间，确保时间无误：&lt;/p&gt;
&lt;p&gt;sudo apt-get install ntpdate&lt;br&gt;sudo ntpdate time.windows.com&lt;/p&gt;
&lt;p&gt;&amp;ensp;&lt;br&gt;在ntpdate.com 这一步遇到no server
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux-解决mariadb安装失败</title>
    <link href="http://yoursite.com/posts/a042bf99/"/>
    <id>http://yoursite.com/posts/a042bf99/</id>
    <published>2018-03-13T04:55:00.000Z</published>
    <updated>2018-03-24T01:21:57.966Z</updated>
    
    <content type="html"><![CDATA[<p>mariadb 与 mysql 的区别：<br><a href="http://www.jb51.net/article/72416.htm" target="_blank" rel="noopener">http://www.jb51.net/article/72416.htm</a></p><p>解决mariadb-server，mariadb-client安装失败<br><img src="http://p3d1icyx2.bkt.clouddn.com/5b2c371fb8b37d28b8dceae1a22720b0.png" alt=""></p><blockquote><p>1.查看已安装的 mariadb相关包<br><img src="http://p3d1icyx2.bkt.clouddn.com/97a7bbb278e0f97d35e737c929f36079.png" alt=""></p><ol><li><p>将这些依赖包卸载<br>sudo yum remove mariadb101u-config<em><br>sudo yum remove mariadb101u-libs</em></p></li><li><p>新建mariadb的源文件<br>sudo vim MariaDB.repo  （建议取这个名字）<br>输入以下内容（该源为清华源，国外源实在太慢）：<br>[mariadb]<br>name = MariaDB<br>baseurl = <a href="https://mirrors.ustc.edu.cn/mariadb/yum/10.1/centos7-amd64" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/mariadb/yum/10.1/centos7-amd64</a><br>gpgkey=<a href="https://mirrors.ustc.edu.cn/mariadb/yum/RPM-GPG-KEY-MariaDB" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/mariadb/yum/RPM-GPG-KEY-MariaDB</a><br>gpgcheck=1</p></li></ol><p>4.安装<br>sudo yum install MariaDB-server MariaDB-client</p></blockquote><p>注意：<br>If you don’t have the MariaDB GPG Signing key installed, YUM will prompt you to install it after downloading the packages (but before installing them).</p><p>mariadb-server 和 mariadb-client 安装包<br><a href="http://yum.mariadb.org/10.1/centos7-amd64" target="_blank" rel="noopener">http://yum.mariadb.org/10.1/centos7-amd64</a></p><p><a href="http://yum.mariadb.org/10.1/centos7-amd64" target="_blank" rel="noopener">http://yum.mariadb.org/10.1/centos7-amd64</a> rpms目录 和 srpms目录的区别<br>RPMS中的软件包是直接可以用rpm来安装的,而SRPMS中的软件包是需要先编译在用rpm安装的</p><p>启动及配置mariadb<br><a href="https://www.linuxidc.com/Linux/2016-03/128880.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2016-03/128880.htm</a></p><p>参考教程：<br><a href="https://www.jianshu.com/p/61e9cbd1b675" target="_blank" rel="noopener">https://www.jianshu.com/p/61e9cbd1b675</a><br><a href="https://mariadb.com/kb/en/library/yum/" target="_blank" rel="noopener">https://mariadb.com/kb/en/library/yum/</a><br><a href="https://www.centos.bz/2017/12/%E5%AE%89%E8%A3%85mariadb%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95-%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E6%BA%90/" target="_blank" rel="noopener">https://www.centos.bz/2017/12/%E5%AE%89%E8%A3%85mariadb%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95-%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E6%BA%90/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mariadb 与 mysql 的区别：&lt;br&gt;&lt;a href=&quot;http://www.jb51.net/article/72416.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.jb51.net/article/72416.
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Python-9-Logging日志模块介绍</title>
    <link href="http://yoursite.com/posts/9559a831/"/>
    <id>http://yoursite.com/posts/9559a831/</id>
    <published>2018-03-12T13:59:00.000Z</published>
    <updated>2018-03-13T04:51:34.196Z</updated>
    
    <content type="html"><![CDATA[<h5 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h5><p><a href="https://docs.python.org/3.5/library/logging.html" target="_blank" rel="noopener">https://docs.python.org/3.5/library/logging.html</a></p><h5 id="入门教程"><a href="#入门教程" class="headerlink" title="入门教程"></a>入门教程</h5><p><a href="https://docs.python.org/3.5/howto/logging.html#logging-basic-tutorial" target="_blank" rel="noopener">https://docs.python.org/3.5/howto/logging.html#logging-basic-tutorial</a></p><p>参考教程：<br><a href="http://blog.yubangweb.com/liao-liao-ri-zhi-zhe-jian-xiao-shi-qing/" target="_blank" rel="noopener">http://blog.yubangweb.com/liao-liao-ri-zhi-zhe-jian-xiao-shi-qing/</a><br><a href="http://python.jobbole.com/86887/" target="_blank" rel="noopener">http://python.jobbole.com/86887/</a></p><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>该模块定义了一系列函数和类(继承的是一个灵活的日志记录系统)来为应用程序和库的日志记录提供便利。</p><p>Logging模块的基类主要由以下几个模块组成：<br>Loggers模块： expose the interface that application code directly uses.<br>Handlers模块： send the log records (created by loggers) to the appropriate destination.<br>Filters模块：provide a finer grained facility for determining which log records to output.<br>Formatters模块：specify(指定) the layout of log records in the final output.</p><h5 id="16-6-1-Logger-对象"><a href="#16-6-1-Logger-对象" class="headerlink" title="16.6.1. Logger 对象"></a>16.6.1. Logger 对象</h5><p>Logger对象有以下的属性和方法。注意Logger从不直接实例化，而是始终通过模块级函数 logging.getLogger(name)。getLogger()函数对同名的多个调用将始终返回对同一个Logger对象的引用。<br>Logger的方法有很多，建议有需要上官方文档查询即可。</p><h5 id="16-6-2-Logging-日志级别"><a href="#16-6-2-Logging-日志级别" class="headerlink" title="16.6.2. Logging 日志级别"></a>16.6.2. Logging 日志级别</h5><p>下图即是 Logging的日志级别。日志一般分为五个级别，分别是 DEBUG、INFO、WARNING、ERROR和CRITICAL。默认的级别是 WARNING。<br><img src="http://hdoc.scau.edu.cn/Public/Uploads/2018-01-21/5a64b20f3ab55.JPG" alt=""></p><h5 id="16-6-3-Handler-对象"><a href="#16-6-3-Handler-对象" class="headerlink" title="16.6.3. Handler 对象"></a>16.6.3. Handler 对象</h5><p>Handler对象有以下的属性和方法。注意Handler从不直接实例化，该类主要作为其他更有用的子类的基类，但要注意，子类的 __init__() 需要调用 Handler的__init<em>__</em>().</p><blockquote><p>Handler.<strong>init</strong>(level=NOTSET)<br>Handler通过设置其级别来初始化实例，将过滤器列表设置为空列表，并创建一个锁（使用createLock()）来序列化对I / O机制的访问<br>Handler的其他方法见官网。</p></blockquote><h5 id="下面的方法有需求再补充"><a href="#下面的方法有需求再补充" class="headerlink" title="下面的方法有需求再补充"></a>下面的方法有需求再补充</h5><p>16.6.4. Formatter Objects</p><p>16.6.5. Filter Objects</p><p>16.6.6. LogRecord Objects</p><p>16.6.7. LogRecord attributes</p><p>16.6.8. LoggerAdapter Objects</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;官方文档&quot;&gt;&lt;a href=&quot;#官方文档&quot; class=&quot;headerlink&quot; title=&quot;官方文档&quot;&gt;&lt;/a&gt;官方文档&lt;/h5&gt;&lt;p&gt;&lt;a href=&quot;https://docs.python.org/3.5/library/logging.html&quot; tar
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python-10-Web开发-网络爬虫教程-翻译版</title>
    <link href="http://yoursite.com/posts/2fc22776/"/>
    <id>http://yoursite.com/posts/2fc22776/</id>
    <published>2018-03-12T13:59:00.000Z</published>
    <updated>2018-03-13T04:51:54.093Z</updated>
    
    <content type="html"><![CDATA[<p>最近想学爬虫，在网上搜索良久，终于找到一篇/良心的爬虫教程，但是教程用的是Python2，而我用的是Python3,顺便再加上我自己的理解，故称为翻译版，希望能帮到大家！<br>参考教程：<a href="https://piaosanlang.gitbooks.io/spiders/01day/section1.1.html" target="_blank" rel="noopener">https://piaosanlang.gitbooks.io/spiders/01day/section1.1.html</a></p><h4 id="爬虫入门至初级篇"><a href="#爬虫入门至初级篇" class="headerlink" title="爬虫入门至初级篇"></a>爬虫入门至初级篇</h4><h5 id="1-为什么要学爬虫"><a href="#1-为什么要学爬虫" class="headerlink" title="1.为什么要学爬虫"></a>1.为什么要学爬虫</h5><p>抢票神器（360抢票器）：</p><ul><li>先用软件注册一千个账号，然后生成一千个身份信息。</li><li>刷票前把这一千个账号批量登陆，cookie独立保存。</li><li>设置好区间跟车次，获取验证码。</li><li>识别验证码。</li><li>伪造订单数据直接提交服务器。</li></ul><p>投票神器（微信朋友圈投票）： 原理应该是模拟出多个用户进行投票<br>咨询报告：下阶段可以尝试<br>对某个App的下载量跟踪<br>饮食地图（NLP分析）</p><h5 id="2-认识爬虫"><a href="#2-认识爬虫" class="headerlink" title="2.认识爬虫"></a>2.认识爬虫</h5><p>起源：搜索引擎<br>发展趋势：抓取Ajax动态页面，需要解决以下问题</p><ul><li>第一：JavaScript的交互分析和解释？</li><li>第二：DOM事件的处理和解释分发？</li><li>第三：动态DOM内容语义的抽取？</li></ul><p>本质： 浏览器Http请求</p><h4 id="3-爬虫基本原理"><a href="#3-爬虫基本原理" class="headerlink" title="3.爬虫基本原理"></a>3.爬虫基本原理</h4><p>怎样理解HTTP协议传输的内容是明文的？<br>《图解HTTP》</p><p><a href="http://www.techug.com/post/https-ssl-tls.html" target="_blank" rel="noopener">Http与Https的区别</a></p><p><a href="https://www.jianshu.com/p/e4fd0ba780a5" target="_blank" rel="noopener">数字证书及CA的扫盲介绍</a></p><h4 id="4-HTTP代理神器Fiddler"><a href="#4-HTTP代理神器Fiddler" class="headerlink" title="4.HTTP代理神器Fiddler"></a>4.HTTP代理神器Fiddler</h4><p>为什么必须关闭浏览器代理？因为代理的IP和端口冲突？<br>其实我觉得用chrome的开发者工具也挺好的，可能是我对Fiddler还不够了解，毕竟网上有很多人都在推荐这个工具。</p><h4 id="5-HTTP请求-HTTP响应"><a href="#5-HTTP请求-HTTP响应" class="headerlink" title="5.HTTP请求+HTTP响应"></a>5.HTTP请求+HTTP响应</h4><p>感觉作者这两节讲得不错，把请求和响应的参数都说得很全。</p><h4 id="6-学习使用Urllib2库"><a href="#6-学习使用Urllib2库" class="headerlink" title="6.学习使用Urllib2库"></a>6.学习使用Urllib2库</h4><p>urllib2、urllib.request、urllib3、requests的区别：<a href="http://blog.csdn.net/study_000/article/details/72764416" target="_blank" rel="noopener">http://blog.csdn.net/study_000/article/details/72764416</a></p><p>urllib.request.Request: This class is an abstraction of a URL request.<br>request.urlopen:</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近想学爬虫，在网上搜索良久，终于找到一篇/良心的爬虫教程，但是教程用的是Python2，而我用的是Python3,顺便再加上我自己的理解，故称为翻译版，希望能帮到大家！&lt;br&gt;参考教程：&lt;a href=&quot;https://piaosanlang.gitbooks.io/sp
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python-11-Pycharm小技巧</title>
    <link href="http://yoursite.com/posts/7d10c5a7/"/>
    <id>http://yoursite.com/posts/7d10c5a7/</id>
    <published>2018-03-12T13:59:00.000Z</published>
    <updated>2018-03-24T01:21:57.969Z</updated>
    
    <content type="html"><![CDATA[<p>Favotites： 可以查看断点</p><p>ycharm搜索导航之文件名、符号名搜索<br><a href="http://blog.csdn.net/u013088062/article/details/50323393" target="_blank" rel="noopener">http://blog.csdn.net/u013088062/article/details/50323393</a></p><p>PyCharm中设置断点却不执行的原因<br><a href="https://jingyan.baidu.com/article/e75057f2eb1ec7ebc91a8985.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/e75057f2eb1ec7ebc91a8985.html</a></p><p>Pycharm如何实现变量的批量重命名<br>Ctrl + R   替换<br>Ctrl + Shift + F   全局查找<br>Ctrl + Shift + R   全局替换</p><p>pycharm：格式化python代码<br>ctrl+alt+L可以格式化</p><p>pycharm Tab键设置成4个空格<br><a href="https://www.cnblogs.com/Will-guo/p/6321843.html" target="_blank" rel="noopener">https://www.cnblogs.com/Will-guo/p/6321843.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Favotites： 可以查看断点&lt;/p&gt;
&lt;p&gt;ycharm搜索导航之文件名、符号名搜索&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/u013088062/article/details/50323393&quot; target=&quot;_blank&quot; rel=&quot;
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python-6-模块介绍</title>
    <link href="http://yoursite.com/posts/7ba23f82/"/>
    <id>http://yoursite.com/posts/7ba23f82/</id>
    <published>2018-03-12T13:54:00.000Z</published>
    <updated>2018-03-24T01:21:57.970Z</updated>
    
    <content type="html"><![CDATA[<p>在我的涉猎中，Python模块一般会涉及到这几个问题：</p><p>1 __init<strong>文件的作用<br>\</strong>init__文件 可以区别文件夹是 Python模块还是 Python目录，Python模块可以被调用，目录不行。</p><p>不明白json模块的 loads等方法是写在 __init__文件中？</p><p>2 import xxx 和 from xxx import x 和 import xxx as xx 的区别<br>举个例子, 有个 hello.py 文件，假设 hello.py 可以当作模块使用，它的代码如下<br><img src="http://p3d1icyx2.bkt.clouddn.com/e3d73cf3e1ed614a385883f1153e0ada.png" alt=""></p><p>有三种调用它的方法</p><blockquote><p>1 import PythonTest.module_test.hello<br>这种方法导入了 hello 模块的全部方法，如果 hello 模块包含方法较多，占用的内存会比较大</p><p>2 import PythonTest.module_test.hello as hello<br>这种方法和 import PythonTest.module_test.hello 本质一样，都是导入所有方法，区别在于import PythonTest.module_test.hello as hello 给 PythonTest.module_test.hello 赋予了一个别名 hello，调用起来更方便，代码也更简洁</p><p>3 from PythonTest.module_test.hello import print_age<br>从 PythonTest.module_test.hello 模块导入 print_age 方法，只导入单个方法，占用内存小很多</p></blockquote><p>3  if.__name<strong>  == ‘\</strong>main<strong>‘ 语句的作用<br>该语句主要是用于代码测试。<br>如上图的例子，当在命令行执行 python3 hello.py 时，会依次执行print_name、print_age、print_sex这三个方法，因为这时候 \</strong>name<strong> 等于 ‘\</strong>main<strong>‘，if 语句执行。反之，当你是调用而不是执行该模块时，\</strong>name<strong> 不等于 ‘\</strong>main__’，三个方法不会被执行，所以起到测试代码的作用。</p><p>4 global 关键字的用法<br><img src="http://p3d1icyx2.bkt.clouddn.com/b5b89942fd8abf52b012b97c8b75eda8.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在我的涉猎中，Python模块一般会涉及到这几个问题：&lt;/p&gt;
&lt;p&gt;1 __init&lt;strong&gt;文件的作用&lt;br&gt;\&lt;/strong&gt;init__文件 可以区别文件夹是 Python模块还是 Python目录，Python模块可以被调用，目录不行。&lt;/p&gt;
&lt;p&gt;不明
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python-5-异常介绍</title>
    <link href="http://yoursite.com/posts/427be274/"/>
    <id>http://yoursite.com/posts/427be274/</id>
    <published>2018-03-12T13:54:00.000Z</published>
    <updated>2018-03-24T01:21:57.971Z</updated>
    
    <content type="html"><![CDATA[<p>此篇文章是Python介绍的第五部分：异常介绍</p><p>Python的异常处理有两种方式，第一种是用 try…except捕获异常，并用日志记录或者用print()打印出来；第二种是用raise关键字显示抛出异常。两者的区别是是程序的后续代码能否在出现异常后仍然能够执行。</p><p><img src="http://p3d1icyx2.bkt.clouddn.com/fb76411c806120b06b1670c0e7eb98e0.png" alt=""></p><blockquote><p>error<br> end<br> ### 后续代码print(‘end’)能够执行</p></blockquote><p><img src="http://p3d1icyx2.bkt.clouddn.com/e322519212030bce0b44bb50889a4795.png" alt=""></p><p><img src="http://p3d1icyx2.bkt.clouddn.com/169ff9f03953f95a91e4582dc53ca748.png" alt=""></p><blockquote><p>### 后续代码print(‘end’)不能执行</p></blockquote><p>如果我们在程序中没有try或者raise异常，在程序出现错误时，程序也会抛出异常，其实是隐式地调用了raise。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;此篇文章是Python介绍的第五部分：异常介绍&lt;/p&gt;
&lt;p&gt;Python的异常处理有两种方式，第一种是用 try…except捕获异常，并用日志记录或者用print()打印出来；第二种是用raise关键字显示抛出异常。两者的区别是是程序的后续代码能否在出现异常后仍然能够执
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python-4-数据结构介绍</title>
    <link href="http://yoursite.com/posts/c6793824/"/>
    <id>http://yoursite.com/posts/c6793824/</id>
    <published>2018-03-12T13:34:00.000Z</published>
    <updated>2018-03-17T01:57:30.867Z</updated>
    
    <content type="html"><![CDATA[<p>此篇文章是Python介绍的第四部分：数据结构介绍</p><p><img src="http://p3d1icyx2.bkt.clouddn.com/eeb848288fc726e603671bfb5058e009.png" alt=""></p><p>仅供参考哦！</p><p>dict 替换 key （dict[new_key] = value = dict.pop(key)）<br><a href="http://blog.csdn.net/jt674106399/article/details/76516186" target="_blank" rel="noopener">http://blog.csdn.net/jt674106399/article/details/76516186</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;此篇文章是Python介绍的第四部分：数据结构介绍&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3d1icyx2.bkt.clouddn.com/eeb848288fc726e603671bfb5058e009.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;仅供参考哦！&lt;/
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python-1-数据类型及字符串格式化介绍</title>
    <link href="http://yoursite.com/posts/ca0c3673/"/>
    <id>http://yoursite.com/posts/ca0c3673/</id>
    <published>2018-03-12T13:09:00.000Z</published>
    <updated>2018-03-13T04:48:42.108Z</updated>
    
    <content type="html"><![CDATA[<p>此篇文章是Python介绍的第一部分：数据类型及字符串格式化介绍。</p><p>Python 常见的数据类型有整型、浮点型及字符串。他们之间的转换可以通过 int（）、float（）、str（）这三个方法。</p><p>在实际的运用中，浮点数常常需要精度保留，这时 round（） 方法便发挥上用场。</p><blockquote><p>>&gt;&gt; f = 1.234567<br>>&gt;&gt; print(round(f, 2))<br> 1.23</p></blockquote><p> 另外，字符串的格式化也比较常见。</p><blockquote><p>>&gt;&gt; i = 18<br>>&gt;&gt; f = 40.0234<br>>&gt;&gt; s = ‘John’<br>>&gt;&gt; print(‘the age of %s is %d, his salary are %.2f’ % (s, i, f))<br>the age of John is 18, his salary are 40.02</p></blockquote><p>str()和repr()两个内建函数之间的差异：<br>str()得到的字符串是面向用户的，具有较好的可读性<br>repr()得到的字符串是面向机器的</p><blockquote><p>>&gt;&gt; string = “Hello\tWill\n”<br>>&gt;&gt; print(“%s” % string)<br>>&gt;&gt; print(“%r” % string)<br>Hello    Will<br>&ensp;<br>‘Hello\tWill\n’</p></blockquote><p>参考教程<br><a href="https://www.cnblogs.com/wilber2013/p/4641616.html" target="_blank" rel="noopener">https://www.cnblogs.com/wilber2013/p/4641616.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;此篇文章是Python介绍的第一部分：数据类型及字符串格式化介绍。&lt;/p&gt;
&lt;p&gt;Python 常见的数据类型有整型、浮点型及字符串。他们之间的转换可以通过 int（）、float（）、str（）这三个方法。&lt;/p&gt;
&lt;p&gt;在实际的运用中，浮点数常常需要精度保留，这时 ro
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux-用户及用户组介绍</title>
    <link href="http://yoursite.com/posts/ae5c165a/"/>
    <id>http://yoursite.com/posts/ae5c165a/</id>
    <published>2018-03-07T02:08:00.000Z</published>
    <updated>2018-03-07T02:09:13.809Z</updated>
    
    <content type="html"><![CDATA[<p>简介：<br>Linux 是一个多用户、多任务的操作系统。</p><h5 id="用户及用户组概念介绍：-https-www-cnblogs-com-jackyyou-p-5498083-html"><a href="#用户及用户组概念介绍：-https-www-cnblogs-com-jackyyou-p-5498083-html" class="headerlink" title="用户及用户组概念介绍：  https://www.cnblogs.com/jackyyou/p/5498083.html"></a>用户及用户组概念介绍：  <a href="https://www.cnblogs.com/jackyyou/p/5498083.html" target="_blank" rel="noopener">https://www.cnblogs.com/jackyyou/p/5498083.html</a></h5><p>在使用Linux的过程中，我们一般不使用root用户来执行操作，因为root的权限太大，我们容易误删文件及其他操作，所以我们一般会新建多个用户来管理不同的任务。</p><p>本人同时拥有root用户及一个名为hadoop的用户，正常来讲，当你用adduser或者useradd来创建用户时，该用户（hadoop）在命令前加 sudo 是无效的，见下图。原因是你没有将这个用户加入到 sudoers 这份文件中。<br><img src="http://p3d1icyx2.bkt.clouddn.com/9c4303b1acba473ad1af03ca77cff2b4.png" alt=""></p><h5 id="将hadoop加入sudo用户组"><a href="#将hadoop加入sudo用户组" class="headerlink" title="将hadoop加入sudo用户组"></a>将hadoop加入sudo用户组</h5><p>从实际操作上讲，将hadoop加入sudo用户组有两种方式：</p><blockquote><p>第一是使用 vim 打开，但是在最后保存的时候他会提示这是只读文件，可以强制保存，但不知道有没有效<br>vim /etc/sudoers</p><p>第二是使用 visudo 命令打开，这是系统规定的方式<br>sudo visudo</p></blockquote><p>打开文件后，我们可以看到如下内容：<br><img src="http://p3d1icyx2.bkt.clouddn.com/b80b20048904543f06797315e8e82018.png" alt=""></p><p>可以看到，要让hadoop用户能够使用sudo命令，有两种方式：</p><blockquote><p>第一是在 root    ALL=(ALL)       ALL 这条语句下添加<br>hadoop    ALL=(ALL)       ALL</p><p>第二是将用户hadoop加到wheel用户组，因为这个用户组也拥有root权限</p></blockquote><p>小提示：<br>在安装Centos7系统的过程中，会出现如下界面，当你点击创建用户时，会让你输入用户名及密码，下面还有一个是否设置为管理员的选项。当你点击设置为管理员时，就会默认将该用户加到wheel组，所以能够使用sudo命令。<br><img src="http://p3d1icyx2.bkt.clouddn.com/5c3e24a8425fb738d604fa8493fee200.png" alt=""></p><h5 id="输入sudo命令免密码："><a href="#输入sudo命令免密码：" class="headerlink" title="输入sudo命令免密码："></a>输入sudo命令免密码：</h5><p>如果你的用户是在wheel组，则将 sudoers文件中的 #%wheel  ALL=(ALL)       NOPASSWD: ALL 取消注释即可；如果不在，则仿照该格式添加即可。如下</p><blockquote><p>hadoop  ALL=(ALL)       NOPASSWD: ALL</p></blockquote><h5 id="添加用户："><a href="#添加用户：" class="headerlink" title="添加用户："></a>添加用户：</h5><p><a href="https://www.linuxidc.com/Linux/2017-02/140794.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2017-02/140794.htm</a></p><h5 id="sudoers-文件内容翻译："><a href="#sudoers-文件内容翻译：" class="headerlink" title="sudoers 文件内容翻译："></a>sudoers 文件内容翻译：</h5><p><a href="http://blog.csdn.net/a19881029/article/details/18730671" target="_blank" rel="noopener">http://blog.csdn.net/a19881029/article/details/18730671</a></p><h5 id="常见命令及文件说明："><a href="#常见命令及文件说明：" class="headerlink" title="常见命令及文件说明："></a>常见命令及文件说明：</h5><p>groups 查看当前登录用户的组内成员<br>groups gliethttp 查看gliethttp用户所在的组,以及组内成员<br>whoami 查看当前登录用户名</p><p>/etc/group文件包含所有组<br>/etc/shadow和/etc/passwd系统存在的所有用户名</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><p><a href="https://www.cnblogs.com/jackyyou/p/5498083.html" target="_blank" rel="noopener">https://www.cnblogs.com/jackyyou/p/5498083.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简介：&lt;br&gt;Linux 是一个多用户、多任务的操作系统。&lt;/p&gt;
&lt;h5 id=&quot;用户及用户组概念介绍：-https-www-cnblogs-com-jackyyou-p-5498083-html&quot;&gt;&lt;a href=&quot;#用户及用户组概念介绍：-https-www-cnbl
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Python-8-内建模块datetime介绍-转载</title>
    <link href="http://yoursite.com/posts/e022544/"/>
    <id>http://yoursite.com/posts/e022544/</id>
    <published>2018-02-18T10:20:00.000Z</published>
    <updated>2018-03-13T04:51:21.169Z</updated>
    
    <content type="html"><![CDATA[<p>转载链接：<br><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431937554888869fb52b812243dda6103214cd61d0c2000" target="_blank" rel="noopener">廖雪峰常用内建模块datetime</a></p><p>参考教程：<br><a href="http://www.jb51.net/article/75364.htm" target="_blank" rel="noopener">Python中time模块与datetime模块在使用中的不同之处</a></p><h4 id="时间模块的种类"><a href="#时间模块的种类" class="headerlink" title="时间模块的种类"></a>时间模块的种类</h4><p>Python时间模块主要有 datetime 、time、 calendar 这三个，其中time比较接近底层，datetime是time的封装。</p><h4 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h4><blockquote><p>from datetime import datetime, timedelta, timezone</p></blockquote><h4 id="获取当前日期和时间"><a href="#获取当前日期和时间" class="headerlink" title="获取当前日期和时间"></a>获取当前日期和时间</h4><blockquote><p>print(datetime.now())<br>print(type(datetime.now()))  # datetime</p></blockquote><h4 id="获取指定日期和时间"><a href="#获取指定日期和时间" class="headerlink" title="获取指定日期和时间"></a>获取指定日期和时间</h4><blockquote><p>dt = datetime(2018, 2, 18, 17, 12, 54, 30000)<br>print(dt, dt.year, dt.tzinfo)</p></blockquote><h4 id="datetime转换为timestamp"><a href="#datetime转换为timestamp" class="headerlink" title="datetime转换为timestamp"></a>datetime转换为timestamp</h4><blockquote><p>dt = datetime(2018, 2, 18, 17, 12, 54, 30000)<br>print(dt.timestamp()) # 1518945174.03</p></blockquote><h4 id="timestamp转换为datetime"><a href="#timestamp转换为datetime" class="headerlink" title="timestamp转换为datetime"></a>timestamp转换为datetime</h4><p># 注意到timestamp是一个浮点数，它没有时区的概念，而datetime是有时区的。上述转换是在timestamp和本地时间做转换。</p><blockquote><p>t = 1518945174.03<br>print(datetime.fromtimestamp(t))<br>print(datetime.utcfromtimestamp(t))  # 差了8个小时</p></blockquote><h4 id="str转换为timestamp-str-gt-datetime-gt-timestamp"><a href="#str转换为timestamp-str-gt-datetime-gt-timestamp" class="headerlink" title="str转换为timestamp: str-&gt;datetime-&gt;timestamp"></a>str转换为timestamp: str-&gt;datetime-&gt;timestamp</h4><p>%Y, %m, %d 代表的含义:<br><a href="https://zhidao.baidu.com/question/484985079.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/484985079.html</a><br><a href="https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior" target="_blank" rel="noopener">https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior</a></p><blockquote><p>s = ‘2018-02-18 17:12:54’<br>sdt = datetime.strptime(s, ‘%Y-%m-%d %H:%M:%S’)  # strptime记忆: str parse time    so return datetime<br>print(sdt)<br>print(type(sdt))   # datetime<br>stt = sdt.timestamp()<br>print(stt)</p></blockquote><h4 id="timestamp转换为str-timestamp-gt-datetime-gt-str"><a href="#timestamp转换为str-timestamp-gt-datetime-gt-str" class="headerlink" title="timestamp转换为str: timestamp-&gt;datetime-&gt;str"></a>timestamp转换为str: timestamp-&gt;datetime-&gt;str</h4><blockquote><p>tt = 1518945174.03<br>tt2dt = datetime.fromtimestamp(tt)<br>print(tt2dt)<br>dt2str = datetime.strftime(tt2dt, ‘%Y-%m-%d %H:%M:%S’) # str_format_time, return str<br>print(dt2str)<br>print(type(dt2str))  # str</p></blockquote><h4 id="datetime-指定时区"><a href="#datetime-指定时区" class="headerlink" title="datetime 指定时区"></a>datetime 指定时区</h4><blockquote><p>tz_utc_8 = timezone(timedelta(hours=8))<br>now = datetime.now()<br>print(now)<br>dt = now.replace(tzinfo=tz_utc_8)<br>print(dt)</p><p>tokyo_dt = dt.astimezone(timezone(timedelta(hours=9)))<br>print(tokyo_dt)</p></blockquote><h4 id="练习：-假设你获取了用户输入的日期和时间如2015-1-21-9-01-30，以及一个时区信息如UTC-5-00，均是str，请编写一个函数将其转换为timestamp"><a href="#练习：-假设你获取了用户输入的日期和时间如2015-1-21-9-01-30，以及一个时区信息如UTC-5-00，均是str，请编写一个函数将其转换为timestamp" class="headerlink" title="练习： 假设你获取了用户输入的日期和时间如2015-1-21 9:01:30，以及一个时区信息如UTC+5:00，均是str，请编写一个函数将其转换为timestamp"></a>练习： 假设你获取了用户输入的日期和时间如2015-1-21 9:01:30，以及一个时区信息如UTC+5:00，均是str，请编写一个函数将其转换为timestamp</h4><blockquote><p>def str_to_timestamp(dt_str, tz_str):<br>    tz_num = int(tz_str[4:5])<br>    tz_spec = timezone(timedelta(hours=tz_num))<br>    dt = datetime.strptime(dt_str, ‘%Y-%m-%d %H:%M:%S’)<br>    dt_tz_spec = dt.replace(tzinfo=tz_spec)<br>    dt2tt = dt_tz_spec.timestamp()<br>    return dt2tt</p><p>t1 = str_to_timestamp(‘2015-6-1 08:10:30’, ‘UTC+7:00’)<br>print(t1)  # 1433121030.0</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载链接：&lt;br&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431937554888869fb52b812243dda610
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python-7-IO读写-open方法介绍</title>
    <link href="http://yoursite.com/posts/be6c44be/"/>
    <id>http://yoursite.com/posts/be6c44be/</id>
    <published>2018-02-18T05:59:00.000Z</published>
    <updated>2018-03-13T04:51:09.072Z</updated>
    
    <content type="html"><![CDATA[<p>在Python的文件读写中，我们都会经常用到它的内置方法open()，以下就是该方法的简单介绍</p><p>环境<br>Python3.5.4<br>Centos7</p><p>def open(file, mode=’r’, buffering=None, encoding=None, errors=None, newline=None, closefd=True):</p><p>1.open() 默认写入 str 类型，如果想写入 bytes 类型，则mode需加上 ‘b’，除此之外，无法写入其它类型，如 int。<br>2.open()默认以只读模式打开文件，且读取的数据格式一律为 str，不管之前写入的是否是bytes。<br>3.参数说明：<br>3.1 file：文件名称<br>3.2 mode：模式，总分的话有read()、write()、append()三种模式，细分的话有12种。其中，write()会覆盖之前存在的内容，append()代表追加，会将新添加的内容放在原来内容的后面</p><p>此图来自菜鸟教程的“Python 文件I/O”教程，侵删<br><img src="http://p3d1icyx2.bkt.clouddn.com/a5b37fbefad3a445dc3ebad239f217cd.png" alt=""></p><p>3.3 buffing：buffing主要用来设置缓存策略。<br>当buffing为0时，代表关闭缓冲（仅在二进制模式下允许），当buffing为1时，代表行缓冲（只能在文本模式下使用）当buffing为一个大于1的整数时，表示一个固定大小的块缓冲区的大小。没有缓冲参数时给定，即buffering为None时，默认的缓冲策略如下：</p><ul><li><p>二进制文件通常使用固定大小的块来缓冲;块的大小可以通过查看“io.DEFAULT_BUFFER_SIZE”。在很多系统上，缓冲区的长度通常为4096或8192字节。</p></li><li><p>“交互式”文本文件（isatty（）返回True的文件）使用行缓冲。其他文本文件使用上述二进制文件的策略。</p></li></ul><p>3.4 encoding： 用于解码或者编码的编码集名称，比如utf-8等。默认编码依赖与本机平台。<br>3.5 errors： is an optional string that specifies how encoding errors are to be handled—this argument should not be used in binary mode. Pass ‘strict’ to raise a ValueError exception if there is an encoding error (the default of None has the same effect), or pass ‘ignore’ to ignore errors.<br>3.6 newline：控制选择哪种换行符。（仅适用于文本模式）。它可以是None，’’，’\ n’，’\ r’和’\ r \ n’。</p><p>4.open、io.open、codecs.open的区别<br><a href="https://zhidao.baidu.com/question/1823800427851275948.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/1823800427851275948.html</a></p><p>参考教程<br><a href="http://www.runoob.com/python/python-files-io.html" target="_blank" rel="noopener">http://www.runoob.com/python/python-files-io.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Python的文件读写中，我们都会经常用到它的内置方法open()，以下就是该方法的简单介绍&lt;/p&gt;
&lt;p&gt;环境&lt;br&gt;Python3.5.4&lt;br&gt;Centos7&lt;/p&gt;
&lt;p&gt;def open(file, mode=’r’, buffering=None, encod
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python-3-str、bytes、unicode区别介绍</title>
    <link href="http://yoursite.com/posts/3af5ad4e/"/>
    <id>http://yoursite.com/posts/3af5ad4e/</id>
    <published>2018-02-18T05:59:00.000Z</published>
    <updated>2018-03-13T04:49:50.660Z</updated>
    
    <content type="html"><![CDATA[<p>此篇文章是Python介绍的第三部分：str、bytes、unicode区别介绍。</p><p><strong>环境</strong><br>Python3.5.4<br>Centos7</p><p>1.在Python中也存在字节型数据（bytes）和字符型数据（unicode），不过这两者在Python2和Python3中却有点不同。<br><strong>Py2 和 Py3 都用 str 类型来表示字符串</strong>，不过在Py2中，str跟bytes是等价的；在Py3中，str跟unicode是等价的。另外，值得注意的是，在Py2中，bytes跟unicode是等价的；在Py3中则是不等的。详情见下图或者在Python命令行尝试。</p><p>Python2<br><img src="http://p3d1icyx2.bkt.clouddn.com/f32f788d171e857e407e5268b1fd7255.png" alt=""></p><p>Python3<br><img src="http://p3d1icyx2.bkt.clouddn.com/baba273ed6719629b7093c3d08b82bd6.png" alt=""></p><p>2.除此之外，根据博主本人的理解，字节型转换为字符型可以理解为解码（decode），反之则是编码（encode）。<strong>下面只展示Python3的情况</strong><br>首先，我们可以通过 locale 来查看本机的默认编码方式，貌似Linux默认是utf-8，windows默认是gbk。</p><blockquote><p>>&gt;&gt;import locale<br>>&gt;&gt;locale.getpreferredencoding(False)</p></blockquote><p>其次，我们将尝试 字符-&gt;字节</p><blockquote><p>>&gt;&gt;a = ‘学习’<br>>&gt;&gt;ae = a.encode(‘utf-8’)<br>b’\xe5\xad\xa6\xe4\xb9\xa0’</p></blockquote><p>字节-&gt;字符</p><blockquote><p>>&gt;&gt; ae.decode(‘utf-8’)<br>‘学习’</p></blockquote><p>最后，因为在Py3中，字符串与unicode是等价的，所以字符串是没有decode方法的，如果调用该方法则会报错</p><blockquote><p>>&gt;&gt; a.decode(‘utf-8’)<br>Traceback (most recent call last):<br>  File “<stdin>“, line 1, in <module><br>AttributeError: ‘str’ object has no attribute ‘decode’</module></stdin></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;此篇文章是Python介绍的第三部分：str、bytes、unicode区别介绍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;环境&lt;/strong&gt;&lt;br&gt;Python3.5.4&lt;br&gt;Centos7&lt;/p&gt;
&lt;p&gt;1.在Python中也存在字节型数据（bytes）和字符型数据（uni
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python-7-序列化-json模块介绍</title>
    <link href="http://yoursite.com/posts/bf4d5c4/"/>
    <id>http://yoursite.com/posts/bf4d5c4/</id>
    <published>2018-02-18T05:59:00.000Z</published>
    <updated>2018-03-13T04:50:50.347Z</updated>
    
    <content type="html"><![CDATA[<p>环境<br>Python3.5.4<br>Pycharm 2016.3.3<br>Centos7</p><p>在进行网络通信，或者Web开发时，经常用json作为数据交换语言，所以我们都不可避免地会涉及到json模块，以下是该模块的简单介绍。</p><p>在Pycharm中按住Ctrl键并用鼠标点击 json 模块，便可以查看 json 模块的源代码，我们可以看到该源代码都在json模块的<strong>init</strong>.py 中，包含dump、dumps、load、loads这四个方法。<br><img src="http://p3d1icyx2.bkt.clouddn.com/ec4872822a62f3ed6771f88fe670fe11.png" alt=""></p><p>看到这里，不免有人会觉得奇怪，为什么这四个方法是写在<strong>init</strong>.py这份文件中？请听我慢慢道来。</p><ul><li>__init<strong>.py 文件的作用是将文件夹变为一个Python模块,Python 中的每个模块的包中，都有</strong>init__.py 文件。</li><li>通常<strong>init</strong>.py 文件为空，但是我们还可以为它增加其他的功能。我们在导入一个包时，实际上是导入了它的<strong>init</strong>.py文件。这样我们可以在<strong>init</strong>.py文件中批量导入我们所需要的模块，而不再需要一个一个的导入。所以这就是为什么 import json 后可以引用dump等方法。</li><li>欲知更多细节，请查看此文章：<a href="https://www.cnblogs.com/Lands-ljk/p/5880483.html" target="_blank" rel="noopener">https://www.cnblogs.com/Lands-ljk/p/5880483.html</a></li></ul><h4 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h4><ol><li>def dump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None,default=None, sort_keys=False, **kw):</li></ol><p>作用：<strong>将Python对象obj以JSON的格式序列化并存入文件对象fp</strong></p><p><strong>obj:</strong> 要序列化的对象<br><strong>fp:</strong> 要存入的文件对象</p><blockquote><p>>&gt;&gt;with open(“data.json”, “w”, encoding=”UTF-8”) as f_dump:<br>…&ensp;&ensp;&ensp;&ensp;    s_dump = json.dump({‘a’:’22’}, f_dump, ensure_ascii=False)</p></blockquote><p><strong>skipkeys:</strong> 如果skipkeys=True，遇到不符合规范的keys（不是(<code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code>, <code>None</code>)这些类型的），则会跳过该key，不会进行序列化。而如果 skipkeys=False，遇到不符合规范的keys则会报TypeError的错误。<br><strong>ensure_ascii:</strong> 如果ensure_ascii=False，则obj对象中的非ascii字符可以被序列化，反之则会被剔除。<br><strong>check_circular:</strong> 如果check_circular=False，那么容器类型的循环引用检查将被跳过，并且循环引用将导致OverflowError</p><blockquote><p>循环引用举例<br>import itertools<br>for i in itertools.count():<br>    a = {}<br>    b = {“a”:a}<br>    a[“b”] = b<br>它始终保持使用3.6 MB的RAM。</p></blockquote><p><strong>allow_nan:</strong> 首先，nan!=None；其次，nan = float(‘inf’) - float(‘inf’)；最后，float(‘inf’)是∞，一个比其他所有值都大的值。<br>如果allow_nan为Flase， 序列化的对象包含nan、inf、-inf时则会抛出ValuError，如果为True则不会.<br>>&gt;&gt; NaN = float(“NaN”)<br> >&gt;&gt; a = {‘aa’:NaN}<br> >&gt;&gt; import json<br> >&gt;&gt; json.dumps(a)<br>‘{“aa”: NaN}’<br>>&gt;&gt;json.dumps(a, allow_nan=False)<br>ValueError: Out of range float values are not JSON compliant</p><p><strong>indent:</strong> 序列化后的结果以多少个空格缩进,可以美化打印结果<br><strong>separators:</strong> 分隔符<br><strong>sort_keys:</strong> 如果sort_keys为true，则字典的输出将按键排序。<br><strong>cls:</strong> 如果要使用自定义的编码器，即自定义JSONEncoder子类，可以使用“cls“参数指定，，否则默认使用JSONEncoder。</p><ol><li><p>dumps: 与dump方法类似，只不过dumps没有把序列后的对象存入文件，而是直接打印出来</p></li><li><p>def load(fp, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):</p></li></ol><p>作用：<strong>将文件对象fp中的内容反序列化为Python对象，例如dict</strong></p><p><strong>fp:</strong> 要读取的文件对象<br><strong>cls:</strong> 用于自定义解码器<br><strong>object_hook:</strong> object_hook是一个可选函数，当任何对象（如dict）被解码/反序列化时，这个函数就会被调用。object_hook的返回值将被用来代替dict。此功能可用于实现自定义解码器</p><p><strong>object_pairs_hook:</strong> object_pairs_hook是一个可选函数，当任何对象文本都使用‘有序列表对‘’进行解码时被调用，并使用object_pairs_hook的返回值来代替 dict。此功能可用于实现自定义解码器，这些解码器依赖于解码键和值对collections.OrderedDict()的顺序（例如， 会记住插入顺序）。如果定义object_pairs_hook的同时还定义了object_hook，则object_pairs_hook优先。</p><p>4.loads： 与load方法类似，只不过loadss反序列化的对象是字符串，而不是文件对象。</p><h4 id="自定义解码器"><a href="#自定义解码器" class="headerlink" title="自定义解码器"></a>自定义解码器</h4><pre><code>class Decoder(json.JSONDecoder):def decode(self, s):    result = super().decode(s)  # result = super(Decoder,self).decode(s) for Python 2.x    return self._decode(result)def _decode(self, o):    if isinstance(o, str) or isinstance(o, bytes):        try:            return int(o)        except ValueError:            return o    elif isinstance(o, dict):        return {k: self._decode(v) for k, v in o.items()}    elif isinstance(o, list):        return [self._decode(v) for v in o]    else:        return o        &gt;&gt;&gt; c = &apos;{&quot;value&quot;: &quot;42&quot;}&apos;        &gt;&gt;&gt; json.loads(c, cls=Decoder)        {&apos;value&apos;: 42}</code></pre><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://docs.python.org/3/library/json.html" target="_blank" rel="noopener">https://docs.python.org/3/library/json.html</a><br><a href="https://stackoverflow.com/questions/45068797/how-to-convert-string-int-json-into-real-int-with-json-loads" target="_blank" rel="noopener">https://stackoverflow.com/questions/45068797/how-to-convert-string-int-json-into-real-int-with-json-loads</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;环境&lt;br&gt;Python3.5.4&lt;br&gt;Pycharm 2016.3.3&lt;br&gt;Centos7&lt;/p&gt;
&lt;p&gt;在进行网络通信，或者Web开发时，经常用json作为数据交换语言，所以我们都不可避免地会涉及到json模块，以下是该模块的简单介绍。&lt;/p&gt;
&lt;p&gt;在Pychar
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python-2-常见的编码集介绍</title>
    <link href="http://yoursite.com/posts/152d2fee/"/>
    <id>http://yoursite.com/posts/152d2fee/</id>
    <published>2018-02-18T05:59:00.000Z</published>
    <updated>2018-03-13T04:49:35.549Z</updated>
    
    <content type="html"><![CDATA[<p>此篇文章是Python介绍的第二部分：常见的编码集介绍。</p><p>在进行文件读写的过程中，我们不可避免地会遇到编码的问题，以下便是各种编码集的介绍，希望能为读者提供一定帮助。</p><h4 id="位、字节、字符的区别："><a href="#位、字节、字符的区别：" class="headerlink" title="位、字节、字符的区别："></a>位、字节、字符的区别：</h4><p>位：bytes，是存储的最小单位；<br>字节：一个字节等于8位<br>字符：根据编码的不同，一个字符有可能等于1个、2个或者4个及以上字节</p><h4 id="常见的各种编码比较："><a href="#常见的各种编码比较：" class="headerlink" title="常见的各种编码比较："></a>常见的各种编码比较：</h4><p><strong>ASCII：</strong>（American Standard Code for Information Interchange，美国信息交换标准代码），<strong>1967年正式发布</strong>。美国人首先对其英文字符进行了编码，也就是最早的ASCII码，用一个字节的低7位来表示英文的128个字符，最高位统一为0。<br><strong>ISO-8859-1：</strong> 单字节编码，向下兼容ASCII，其编码范围是0x00-0xFF，0x00-0x7F之间完全和ASCII一致，0x80-0x9F之间是控制字符，0xA0-0xFF之间是文字符号。ISO-8859-1收录的字符除ASCII收录的字符外，还包括西欧语言、希腊语、泰语、阿拉伯语、希伯来语对应的文字符号。<br><strong>GB2312-80/CP936：</strong> (GuoBiao)中华人民共和国国家标准简体中文字符集，<strong>1981年发布</strong>。共收录6763个汉字，覆盖99.75%的使用频率，但对于一些罕见字还不能处理。该编码对所收汉字进行分区处理，共计94个区，每个区包含94个汉字/字符。<br><strong>GBK：</strong> (GuoBiaoKuo)汉字内码扩展规范，<strong>1995年发布</strong>。GBK 只为“技术规范指导性文件”，不属于国家标准。GBK向下完全兼容GB2312-80编码，补充了GB2312-80编码缺少的一些罕见字。<br><strong>GB18030：</strong> 国家标准GB 18030-2005《信息技术　中文编码字符集》，<strong>2000年发布</strong>。向后兼容GBK，共收录汉字70244个。采用变长多字节编码，每个字可以由1个、2个或4个字节组成。<br><strong>Unicode：</strong> <strong>1991年公布1.0版本</strong>。在Unicode出现之前，各国之间的编码都不尽相同，西方有ASCII、ISO-8859-1等编码，中国有GB2312等编码，各国之间通信容易出现乱码的问题，所以Unicode就应运而生了，将世界上所有的字符都纳入其中，每一个字符都给予独一无二的编码。<br><strong>UTF-8：</strong> （8-bit Unicode Transformation Format），<strong>1993年正式公布</strong>。是一种针对Unicode的可变长度字元编码。由于Unicode规定一个字符必须为两个字节，对于英文字符来说会增加一倍的存储空间，所以就出现了可变长的UTF-8。</p><p><strong>Unicode到UTF8的转换规则：</strong><br>Unicode         UTF-8<br>0000 - 007F    0xxxxxxx<br>0080 - 07FF    110xxxxx 10xxxxxx<br>0800 - FFFF    1110xxxx 10xxxxxx 10xxxxxx<br>举例：已知“严”的Unicode是4E25（0100-1110-0010-0101），根据上表，可以发现4E25处在第三行的范围内（0800-FFFF），因此“严”的UTF-8编码需要三个字节，即格式是“1110xxxx 10xxxxxx 10xxxxxx”。然后，从“严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了“严”的UTF-8编码是“11100100-10111000- 10100101”，转换成十六进制就是E4B8A5。</p><p>英文字母和中文汉字在不同字符集编码下的字节数<br>|  编码集 | 英文字母  | 中文汉字  |<br>| ———— | ———— | ———— |<br>| ASCII  |  1字节 |  无法表示 |<br>| ISO-8859-1 | 1字节  | 1字节  |<br>| GB2312-80/CP936 | 1字节  | 2字节  |<br>| GBK  | 1字节  | 2字节  |<br>| GB18030 | 1字节  | 2字节  |<br>| Unicode  | 2字节  | 2字节  |<br>| UTF-8  | 1字节  | 3字节  |<br>| UTF-16  | 4字节  | 4字节  |</p><h4 id="参考教程："><a href="#参考教程：" class="headerlink" title="参考教程："></a>参考教程：</h4><p>维基百科<br><a href="http://tool.chinaz.com/tools/utf-8.aspx" target="_blank" rel="noopener">在线编码转换工具</a><br><a href="http://blog.csdn.net/u010737354/article/details/52456570" target="_blank" rel="noopener">英文字母和中文汉字在不同字符集编码下的字节数</a><br><a href="https://baijiahao.baidu.com/s?id=1570122036396262&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1570122036396262&amp;wfr=spider&amp;for=pc</a><br><a href="http://blog.sina.com.cn/s/blog_6966650401013e9q.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_6966650401013e9q.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;此篇文章是Python介绍的第二部分：常见的编码集介绍。&lt;/p&gt;
&lt;p&gt;在进行文件读写的过程中，我们不可避免地会遇到编码的问题，以下便是各种编码集的介绍，希望能为读者提供一定帮助。&lt;/p&gt;
&lt;h4 id=&quot;位、字节、字符的区别：&quot;&gt;&lt;a href=&quot;#位、字节、字符的区别：
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python-11-Pycharm自定义模板</title>
    <link href="http://yoursite.com/posts/c2547b03/"/>
    <id>http://yoursite.com/posts/c2547b03/</id>
    <published>2018-02-01T09:38:00.000Z</published>
    <updated>2018-03-13T04:52:46.044Z</updated>
    
    <content type="html"><![CDATA[<h5 id="Pycharm-设置位置："><a href="#Pycharm-设置位置：" class="headerlink" title="Pycharm 设置位置："></a>Pycharm 设置位置：</h5><p>File-&gt;settings-&gt;Editor-&gt;File and Code Templates-&gt;Python Script</p><h5 id="模板："><a href="#模板：" class="headerlink" title="模板："></a>模板：</h5><p>#!/usr/bin/env python<br># -<em>- coding: utf-8 -</em>-<br># @Time    : ${DATE} ${TIME}<br># @Author  : Aries<br># @Site    : ${SITE}<br># @File    : ${NAME}.py<br># @Software: ${PRODUCT_NAME}</p><h5 id="可用的预定义文件模板变量："><a href="#可用的预定义文件模板变量：" class="headerlink" title="可用的预定义文件模板变量："></a>可用的预定义文件模板变量：</h5><p>$ {PROJECT_NAME} - 当前项目的名称。<br>$ {NAME} - 在文件创建过程中在“新建文件”对话框中指定的新文件的名称。<br>$ {USER} - 当前用户的登录名。<br>$ {DATE} - 当前的系统日期。<br>$ {TIME} - 当前系统时间。<br>$ {YEAR} - 今年。<br>$ {MONTH} - 当月。<br>$ {DAY} - 当月的当天。<br>$ {HOUR} - 目前的小时。<br>$ {MINUTE} - 当前分钟。<br>$ {PRODUCT_NAME} - 将在其中创建文件的IDE的名称。<br>$ {MONTH_NAME_SHORT} - 月份名称的前3个字母。 示例：1月，2月等<br>$ {MONTH_NAME_FULL} - 一个月的全名。 示例：1月，2月等</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><p><a href="https://www.cnblogs.com/mat-wu/p/7130358.html" target="_blank" rel="noopener">https://www.cnblogs.com/mat-wu/p/7130358.html</a><br><a href="https://www.cnblogs.com/ajmd/p/6239146.html" target="_blank" rel="noopener">https://www.cnblogs.com/ajmd/p/6239146.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;Pycharm-设置位置：&quot;&gt;&lt;a href=&quot;#Pycharm-设置位置：&quot; class=&quot;headerlink&quot; title=&quot;Pycharm 设置位置：&quot;&gt;&lt;/a&gt;Pycharm 设置位置：&lt;/h5&gt;&lt;p&gt;File-&amp;gt;settings-&amp;gt;Edit
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python-10-Web开发-Nginx的简单介绍</title>
    <link href="http://yoursite.com/posts/d7e5ae52/"/>
    <id>http://yoursite.com/posts/d7e5ae52/</id>
    <published>2018-02-01T09:34:00.000Z</published>
    <updated>2018-03-13T04:52:05.471Z</updated>
    
    <content type="html"><![CDATA[<h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p>Centos7<br>Nginx  1.12.2</p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>nginx [engine x]是最初由Igor Sysoev编写的HTTP和反向代理服务器，邮件代理服务器和通用TCP / UDP代理服务器。</p><h4 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h4><p><a href="http://www.linuxidc.com/Linux/2017-04/142986.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2017-04/142986.htm</a><br><a href="http://nginx.org/en/docs/beginners_guide.html" target="_blank" rel="noopener">http://nginx.org/en/docs/beginners_guide.html</a></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><blockquote><p>wget <a href="http://dl.Fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm" target="_blank" rel="noopener">http://dl.Fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm</a><br>sudo rpm -ivh epel-release-latest-7.noarch.rpm<br>sudo yum install nginx -y</p></blockquote><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><ol><li>输入 systemctl start nginx 启动 nginx</li><li>在浏览器输入 nginx 服务器的IP 地址，一般为 localhost，出现此页面即安装成功</li></ol><p><img src="http://hdoc.scau.edu.cn/Public/Uploads/2018-01-24/5a686ed675f09.jpg" alt=""></p><h4 id="nginx-常用命令"><a href="#nginx-常用命令" class="headerlink" title="nginx 常用命令"></a>nginx 常用命令</h4><p>(其中 -s 是 signal 的缩写，意思是 nginx 可以通过 quit、stop 这些信号来控制 nginx )</p><blockquote><p>启动：<br>systemctl start nginx<br>sudo nginx<br>&ensp;<br>重启： systemctl restart nginx<br>&ensp;<br>停止：<br>systemctl stop nginx<br>sudo nginx -s quit(优雅地关机)<br>sudo nginx -s stop(快速关机)<br>&ensp;<br>检查状态： systemctl status nginx<br>&ensp;<br>开机自启： systemctl enable nginx<br>&ensp;<br>重新加载配置文件：sudo nginx -s reload</p></blockquote><h4 id="nginx-的权限问题"><a href="#nginx-的权限问题" class="headerlink" title="nginx 的权限问题"></a>nginx 的权限问题</h4><ol><li>本文所安装的 nginx 是由 root 安装的（sudo），所以在执行nginx命令的时候需要系统服务管理指令 systemctl 来执行，否则就很容易报权限不足的错误。</li><li>由于Centos7默认开启 SELinux 服务，这个服务对权限的把控很严格，所以需要先把它关了，这是报权限不足的主要原因。</li></ol><h4 id="nginx-配置文件及目录说明"><a href="#nginx-配置文件及目录说明" class="headerlink" title="nginx 配置文件及目录说明"></a>nginx 配置文件及目录说明</h4><p>注：通过输入 rpm -ql nginx  便可查看安装nginx 所生成的文件</p><ol><li><p>/etc/nginx/nginx.conf： nginx 配置主文件，默认情况下，该配置文件被命名nginx.conf ，并放入目录 /usr/local/nginx/conf， /etc/nginx或 /usr/local/etc/nginx。</p></li><li><p>/etc/nginx/nginx.conf.default :  关于nginx 如何配置的参考文件</p></li><li><p>/etc/nginx/conf.d  和  /etc/nginx/default.d：这两个的共同作用是 放置模块化配置文件，但什么是模块化配置文件呢？就是当你要配置的server 或者 location 比较多的时候，如果全部都放在 nginx.conf 这份文件的话，就会显得很臃肿，这时就可以把这些配置文件放在这两个目录，再通过include命令包含进来，那他们的区别在哪呢？ 在 nginx.conf 这份配置文件中，字段是分为几个级别的，其中 main &gt; events、http；而 http &gt; server &gt; location，由图可得，第一个include （conf.d）与server 是同级别的，第二个 include （default.d）是与location 同级别的，所以在 conf.d 存放server， 在default.d存放 location ，这就是它们的区别。<br><img src="http://hdoc.scau.edu.cn/Public/Uploads/2018-01-24/5a6883d20204b.png" alt=""></p></li><li><p>/usr/share/nginx/html/index.html ： 上图启动页面的HTML文件，是 index.html 的默认存放位置</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h4&gt;&lt;p&gt;Centos7&lt;br&gt;Nginx  1.12.2&lt;/p&gt;
&lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
  </entry>
  
</feed>
