<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hong Xin</title>
  
  <subtitle>大肉丸</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-18T10:20:18.783Z</updated>
  <id>http://yoursite.com/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>转载-Python-时间模块介绍</title>
    <link href="http://yoursite.com/posts/e022544/"/>
    <id>http://yoursite.com/posts/e022544/</id>
    <published>2018-02-18T10:20:00.000Z</published>
    <updated>2018-02-18T10:20:18.783Z</updated>
    
    <content type="html"><![CDATA[<p>参考教程：<br><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431937554888869fb52b812243dda6103214cd61d0c2000" target="_blank" rel="noopener">廖雪峰常用内建模块datetime</a><br><a href="http://www.jb51.net/article/75364.htm" target="_blank" rel="noopener">Python中time模块与datetime模块在使用中的不同之处</a></p><h4 id="时间模块的种类"><a href="#时间模块的种类" class="headerlink" title="时间模块的种类"></a>时间模块的种类</h4><p>Python时间模块主要有 datetime 、time、 calendar 这三个，其中time比较接近底层，datetime是time的封装。</p><h4 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h4><blockquote><p>from datetime import datetime, timedelta, timezone</p></blockquote><h4 id="获取当前日期和时间"><a href="#获取当前日期和时间" class="headerlink" title="获取当前日期和时间"></a>获取当前日期和时间</h4><blockquote><p>print(datetime.now())<br>print(type(datetime.now()))  # datetime</p></blockquote><h4 id="获取指定日期和时间"><a href="#获取指定日期和时间" class="headerlink" title="获取指定日期和时间"></a>获取指定日期和时间</h4><blockquote><p>dt = datetime(2018, 2, 18, 17, 12, 54, 30000)<br>print(dt, dt.year, dt.tzinfo)</p></blockquote><h4 id="datetime转换为timestamp"><a href="#datetime转换为timestamp" class="headerlink" title="datetime转换为timestamp"></a>datetime转换为timestamp</h4><blockquote><p>dt = datetime(2018, 2, 18, 17, 12, 54, 30000)<br>print(dt.timestamp()) # 1518945174.03</p></blockquote><h4 id="timestamp转换为datetime"><a href="#timestamp转换为datetime" class="headerlink" title="timestamp转换为datetime"></a>timestamp转换为datetime</h4><p># 注意到timestamp是一个浮点数，它没有时区的概念，而datetime是有时区的。上述转换是在timestamp和本地时间做转换。</p><blockquote><p>t = 1518945174.03<br>print(datetime.fromtimestamp(t))<br>print(datetime.utcfromtimestamp(t))  # 差了8个小时</p></blockquote><h4 id="str转换为timestamp-str-gt-datetime-gt-timestamp"><a href="#str转换为timestamp-str-gt-datetime-gt-timestamp" class="headerlink" title="str转换为timestamp: str-&gt;datetime-&gt;timestamp"></a>str转换为timestamp: str-&gt;datetime-&gt;timestamp</h4><p>%Y, %m, %d 代表的含义:<br><a href="https://zhidao.baidu.com/question/484985079.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/484985079.html</a><br><a href="https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior" target="_blank" rel="noopener">https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior</a></p><blockquote><p>s = ‘2018-02-18 17:12:54’<br>sdt = datetime.strptime(s, ‘%Y-%m-%d %H:%M:%S’)  # strptime记忆: str parse time    so return datetime<br>print(sdt)<br>print(type(sdt))   # datetime<br>stt = sdt.timestamp()<br>print(stt)</p></blockquote><h4 id="timestamp转换为str-timestamp-gt-datetime-gt-str"><a href="#timestamp转换为str-timestamp-gt-datetime-gt-str" class="headerlink" title="timestamp转换为str: timestamp-&gt;datetime-&gt;str"></a>timestamp转换为str: timestamp-&gt;datetime-&gt;str</h4><blockquote><p>tt = 1518945174.03<br>tt2dt = datetime.fromtimestamp(tt)<br>print(tt2dt)<br>dt2str = datetime.strftime(tt2dt, ‘%Y-%m-%d %H:%M:%S’) # str_format_time, return str<br>print(dt2str)<br>print(type(dt2str))  # str</p></blockquote><h4 id="datetime-指定时区"><a href="#datetime-指定时区" class="headerlink" title="datetime 指定时区"></a>datetime 指定时区</h4><blockquote><p>tz_utc_8 = timezone(timedelta(hours=8))<br>now = datetime.now()<br>print(now)<br>dt = now.replace(tzinfo=tz_utc_8)<br>print(dt)</p><p>tokyo_dt = dt.astimezone(timezone(timedelta(hours=9)))<br>print(tokyo_dt)</p></blockquote><h4 id="练习：-假设你获取了用户输入的日期和时间如2015-1-21-9-01-30，以及一个时区信息如UTC-5-00，均是str，请编写一个函数将其转换为timestamp"><a href="#练习：-假设你获取了用户输入的日期和时间如2015-1-21-9-01-30，以及一个时区信息如UTC-5-00，均是str，请编写一个函数将其转换为timestamp" class="headerlink" title="练习： 假设你获取了用户输入的日期和时间如2015-1-21 9:01:30，以及一个时区信息如UTC+5:00，均是str，请编写一个函数将其转换为timestamp"></a>练习： 假设你获取了用户输入的日期和时间如2015-1-21 9:01:30，以及一个时区信息如UTC+5:00，均是str，请编写一个函数将其转换为timestamp</h4><blockquote><p>def str_to_timestamp(dt_str, tz_str):<br>    tz_num = int(tz_str[4:5])<br>    tz_spec = timezone(timedelta(hours=tz_num))<br>    dt = datetime.strptime(dt_str, ‘%Y-%m-%d %H:%M:%S’)<br>    dt_tz_spec = dt.replace(tzinfo=tz_spec)<br>    dt2tt = dt_tz_spec.timestamp()<br>    return dt2tt</p><p>t1 = str_to_timestamp(‘2015-6-1 08:10:30’, ‘UTC+7:00’)<br>print(t1)  # 1433121030.0</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考教程：&lt;br&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431937554888869fb52b812243dda610
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python-open方法介绍</title>
    <link href="http://yoursite.com/posts/be6c44be/"/>
    <id>http://yoursite.com/posts/be6c44be/</id>
    <published>2018-02-18T05:59:00.000Z</published>
    <updated>2018-02-18T05:59:36.983Z</updated>
    
    <content type="html"><![CDATA[<p>在Python的文件读写中，我们都会经常用到它的内置方法open()，以下就是该方法的简单介绍</p><p>环境<br>Python3.5.4<br>Centos7</p><p>def open(file, mode=’r’, buffering=None, encoding=None, errors=None, newline=None, closefd=True):</p><p>1.open() 默认写入 str 类型，如果想写入 bytes 类型，则mode需加上 ‘b’，除此之外，无法写入其它类型，如 int。<br>2.open()默认以只读模式打开文件，且读取的数据格式一律为 str，不管之前写入的是否是bytes。<br>3.参数说明：<br>3.1 file：文件名称<br>3.2 mode：模式，总分的话有read()、write()、append()三种模式，细分的话有12种。其中，write()会覆盖之前存在的内容，append()代表追加，会将新添加的内容放在原来内容的后面</p><p>此图来自菜鸟教程的“Python 文件I/O”教程，侵删<br><img src="http://p3d1icyx2.bkt.clouddn.com/a5b37fbefad3a445dc3ebad239f217cd.png" alt=""></p><p>3.3 buffing：buffing主要用来设置缓存策略。<br>当buffing为0时，代表关闭缓冲（仅在二进制模式下允许），当buffing为1时，代表行缓冲（只能在文本模式下使用）当buffing为一个大于1的整数时，表示一个固定大小的块缓冲区的大小。没有缓冲参数时给定，即buffering为None时，默认的缓冲策略如下：</p><ul><li><p>二进制文件通常使用固定大小的块来缓冲;块的大小可以通过查看“io.DEFAULT_BUFFER_SIZE”。在很多系统上，缓冲区的长度通常为4096或8192字节。</p></li><li><p>“交互式”文本文件（isatty（）返回True的文件）使用行缓冲。其他文本文件使用上述二进制文件的策略。</p></li></ul><p>3.4 encoding： 用于解码或者编码的编码集名称，比如utf-8等。默认编码依赖与本机平台。<br>3.5 errors： is an optional string that specifies how encoding errors are to be handled—this argument should not be used in binary mode. Pass ‘strict’ to raise a ValueError exception if there is an encoding error (the default of None has the same effect), or pass ‘ignore’ to ignore errors.<br>3.6 newline：控制选择哪种换行符。（仅适用于文本模式）。它可以是None，’’，’\ n’，’\ r’和’\ r \ n’。</p><p>4.open、io.open、codecs.open的区别<br><a href="https://zhidao.baidu.com/question/1823800427851275948.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/1823800427851275948.html</a></p><p>参考教程<br><a href="http://www.runoob.com/python/python-files-io.html" target="_blank" rel="noopener">http://www.runoob.com/python/python-files-io.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Python的文件读写中，我们都会经常用到它的内置方法open()，以下就是该方法的简单介绍&lt;/p&gt;
&lt;p&gt;环境&lt;br&gt;Python3.5.4&lt;br&gt;Centos7&lt;/p&gt;
&lt;p&gt;def open(file, mode=’r’, buffering=None, encod
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>常见的编码集介绍</title>
    <link href="http://yoursite.com/posts/152d2fee/"/>
    <id>http://yoursite.com/posts/152d2fee/</id>
    <published>2018-02-18T05:59:00.000Z</published>
    <updated>2018-02-18T05:59:30.688Z</updated>
    
    <content type="html"><![CDATA[<p>在进行文件读写的过程中，我们不可避免地会遇到编码的问题，以下便是各种编码集的介绍，希望能为读者提供一定帮助。</p><h4 id="位、字节、字符的区别："><a href="#位、字节、字符的区别：" class="headerlink" title="位、字节、字符的区别："></a>位、字节、字符的区别：</h4><p>位：bytes，是存储的最小单位；<br>字节：一个字节等于8位<br>字符：根据编码的不同，一个字符有可能等于1个、2个或者4个及以上字节</p><h4 id="常见的各种编码比较："><a href="#常见的各种编码比较：" class="headerlink" title="常见的各种编码比较："></a>常见的各种编码比较：</h4><p><strong>ASCII：</strong>（American Standard Code for Information Interchange，美国信息交换标准代码），<strong>1967年正式发布</strong>。美国人首先对其英文字符进行了编码，也就是最早的ASCII码，用一个字节的低7位来表示英文的128个字符，最高位统一为0。<br><strong>ISO-8859-1：</strong> 单字节编码，向下兼容ASCII，其编码范围是0x00-0xFF，0x00-0x7F之间完全和ASCII一致，0x80-0x9F之间是控制字符，0xA0-0xFF之间是文字符号。ISO-8859-1收录的字符除ASCII收录的字符外，还包括西欧语言、希腊语、泰语、阿拉伯语、希伯来语对应的文字符号。<br><strong>GB2312-80/CP936：</strong> (GuoBiao)中华人民共和国国家标准简体中文字符集，<strong>1981年发布</strong>。共收录6763个汉字，覆盖99.75%的使用频率，但对于一些罕见字还不能处理。该编码对所收汉字进行分区处理，共计94个区，每个区包含94个汉字/字符。<br><strong>GBK：</strong> (GuoBiaoKuo)汉字内码扩展规范，<strong>1995年发布</strong>。GBK 只为“技术规范指导性文件”，不属于国家标准。GBK向下完全兼容GB2312-80编码，补充了GB2312-80编码缺少的一些罕见字。<br><strong>GB18030：</strong> 国家标准GB 18030-2005《信息技术　中文编码字符集》，<strong>2000年发布</strong>。向后兼容GBK，共收录汉字70244个。采用变长多字节编码，每个字可以由1个、2个或4个字节组成。<br><strong>Unicode：</strong> <strong>1991年公布1.0版本</strong>。在Unicode出现之前，各国之间的编码都不尽相同，西方有ASCII、ISO-8859-1等编码，中国有GB2312等编码，各国之间通信容易出现乱码的问题，所以Unicode就应运而生了，将世界上所有的字符都纳入其中，每一个字符都给予独一无二的编码。<br><strong>UTF-8：</strong> （8-bit Unicode Transformation Format），<strong>1993年正式公布</strong>。是一种针对Unicode的可变长度字元编码。由于Unicode规定一个字符必须为两个字节，对于英文字符来说会增加一倍的存储空间，所以就出现了可变长的UTF-8。</p><p><strong>Unicode到UTF8的转换规则：</strong><br>Unicode         UTF-8<br>0000 - 007F    0xxxxxxx<br>0080 - 07FF    110xxxxx 10xxxxxx<br>0800 - FFFF    1110xxxx 10xxxxxx 10xxxxxx<br>举例：已知“严”的Unicode是4E25（0100-1110-0010-0101），根据上表，可以发现4E25处在第三行的范围内（0800-FFFF），因此“严”的UTF-8编码需要三个字节，即格式是“1110xxxx 10xxxxxx 10xxxxxx”。然后，从“严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了“严”的UTF-8编码是“11100100-10111000- 10100101”，转换成十六进制就是E4B8A5。</p><p>英文字母和中文汉字在不同字符集编码下的字节数<br>|  编码集 | 英文字母  | 中文汉字  |<br>| ———— | ———— | ———— |<br>| ASCII  |  1字节 |  无法表示 |<br>| ISO-8859-1 | 1字节  | 1字节  |<br>| GB2312-80/CP936 | 1字节  | 2字节  |<br>| GBK  | 1字节  | 2字节  |<br>| GB18030 | 1字节  | 2字节  |<br>| Unicode  | 2字节  | 2字节  |<br>| UTF-8  | 1字节  | 3字节  |<br>| UTF-16  | 4字节  | 4字节  |</p><h4 id="参考教程："><a href="#参考教程：" class="headerlink" title="参考教程："></a>参考教程：</h4><p>维基百科<br><a href="http://tool.chinaz.com/tools/utf-8.aspx" target="_blank" rel="noopener">在线编码转换工具</a><br><a href="http://blog.csdn.net/u010737354/article/details/52456570" target="_blank" rel="noopener">英文字母和中文汉字在不同字符集编码下的字节数</a><br><a href="https://baijiahao.baidu.com/s?id=1570122036396262&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1570122036396262&amp;wfr=spider&amp;for=pc</a><br><a href="http://blog.sina.com.cn/s/blog_6966650401013e9q.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_6966650401013e9q.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在进行文件读写的过程中，我们不可避免地会遇到编码的问题，以下便是各种编码集的介绍，希望能为读者提供一定帮助。&lt;/p&gt;
&lt;h4 id=&quot;位、字节、字符的区别：&quot;&gt;&lt;a href=&quot;#位、字节、字符的区别：&quot; class=&quot;headerlink&quot; title=&quot;位、字节、字符的
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>python-json模块介绍</title>
    <link href="http://yoursite.com/posts/bf4d5c4/"/>
    <id>http://yoursite.com/posts/bf4d5c4/</id>
    <published>2018-02-18T05:59:00.000Z</published>
    <updated>2018-02-18T05:59:34.403Z</updated>
    
    <content type="html"><![CDATA[<p>环境<br>Python3.5.4<br>Pycharm 2016.3.3<br>Centos7</p><p>在进行网络通信，或者Web开发时，经常用json作为数据交换语言，所以我们都不可避免地会涉及到json模块，以下是该模块的简单介绍。</p><p>在Pycharm中按住Ctrl键并用鼠标点击 json 模块，便可以查看 json 模块的源代码，我们可以看到该源代码都在json模块的<strong>init</strong>.py 中，包含dump、dumps、load、loads这四个方法。<br><img src="http://p3d1icyx2.bkt.clouddn.com/ec4872822a62f3ed6771f88fe670fe11.png" alt=""></p><p>看到这里，不免有人会觉得奇怪，为什么这四个方法是写在<strong>init</strong>.py这份文件中？请听我慢慢道来。</p><ul><li>__init<strong>.py 文件的作用是将文件夹变为一个Python模块,Python 中的每个模块的包中，都有</strong>init__.py 文件。</li><li>通常<strong>init</strong>.py 文件为空，但是我们还可以为它增加其他的功能。我们在导入一个包时，实际上是导入了它的<strong>init</strong>.py文件。这样我们可以在<strong>init</strong>.py文件中批量导入我们所需要的模块，而不再需要一个一个的导入。所以这就是为什么 import json 后可以引用dump等方法。</li><li>欲知更多细节，请查看此文章：<a href="https://www.cnblogs.com/Lands-ljk/p/5880483.html" target="_blank" rel="noopener">https://www.cnblogs.com/Lands-ljk/p/5880483.html</a></li></ul><h4 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h4><ol><li>def dump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None,default=None, sort_keys=False, **kw):</li></ol><p>作用：<strong>将Python对象obj以JSON的格式序列化并存入文件对象fp</strong></p><p><strong>obj:</strong> 要序列化的对象<br><strong>fp:</strong> 要存入的文件对象</p><blockquote><p>>&gt;&gt;with open(“data.json”, “w”, encoding=”UTF-8”) as f_dump:<br>…&ensp;&ensp;&ensp;&ensp;    s_dump = json.dump({‘a’:’22’}, f_dump, ensure_ascii=False)</p></blockquote><p><strong>skipkeys:</strong> 如果skipkeys=True，遇到不符合规范的keys（不是(<code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code>, <code>None</code>)这些类型的），则会跳过该key，不会进行序列化。而如果 skipkeys=False，遇到不符合规范的keys则会报TypeError的错误。<br><strong>ensure_ascii:</strong> 如果ensure_ascii=False，则obj对象中的非ascii字符可以被序列化，反之则会被剔除。<br><strong>check_circular:</strong> 如果check_circular=False，那么容器类型的循环引用检查将被跳过，并且循环引用将导致OverflowError</p><blockquote><p>循环引用举例<br>import itertools<br>for i in itertools.count():<br>    a = {}<br>    b = {“a”:a}<br>    a[“b”] = b<br>它始终保持使用3.6 MB的RAM。</p></blockquote><p><strong>allow_nan:</strong> 首先，nan!=None；其次，nan = float(‘inf’) - float(‘inf’)；最后，float(‘inf’)是∞，一个比其他所有值都大的值。<br>如果allow_nan为Flase， 序列化的对象包含nan、inf、-inf时则会抛出ValuError，如果为True则不会.<br>>&gt;&gt; NaN = float(“NaN”)<br> >&gt;&gt; a = {‘aa’:NaN}<br> >&gt;&gt; import json<br> >&gt;&gt; json.dumps(a)<br>‘{“aa”: NaN}’<br>>&gt;&gt;json.dumps(a, allow_nan=False)<br>ValueError: Out of range float values are not JSON compliant</p><p><strong>indent:</strong> 序列化后的结果以多少个空格缩进,可以美化打印结果<br><strong>separators:</strong> 分隔符<br><strong>sort_keys:</strong> 如果sort_keys为true，则字典的输出将按键排序。<br><strong>cls:</strong> 如果要使用自定义的编码器，即自定义JSONEncoder子类，可以使用“cls“参数指定，，否则默认使用JSONEncoder。</p><ol><li><p>dumps: 与dump方法类似，只不过dumps没有把序列后的对象存入文件，而是直接打印出来</p></li><li><p>def load(fp, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):</p></li></ol><p>作用：<strong>将文件对象fp中的内容反序列化为Python对象，例如dict</strong></p><p><strong>fp:</strong> 要读取的文件对象<br><strong>cls:</strong> 用于自定义解码器<br><strong>object_hook:</strong> object_hook是一个可选函数，当任何对象（如dict）被解码/反序列化时，这个函数就会被调用。object_hook的返回值将被用来代替dict。此功能可用于实现自定义解码器</p><p><strong>object_pairs_hook:</strong> object_pairs_hook是一个可选函数，当任何对象文本都使用‘有序列表对‘’进行解码时被调用，并使用object_pairs_hook的返回值来代替 dict。此功能可用于实现自定义解码器，这些解码器依赖于解码键和值对collections.OrderedDict()的顺序（例如， 会记住插入顺序）。如果定义object_pairs_hook的同时还定义了object_hook，则object_pairs_hook优先。</p><p>4.loads： 与load方法类似，只不过loadss反序列化的对象是字符串，而不是文件对象。</p><h4 id="自定义解码器"><a href="#自定义解码器" class="headerlink" title="自定义解码器"></a>自定义解码器</h4><pre><code>class Decoder(json.JSONDecoder):def decode(self, s):    result = super().decode(s)  # result = super(Decoder,self).decode(s) for Python 2.x    return self._decode(result)def _decode(self, o):    if isinstance(o, str) or isinstance(o, bytes):        try:            return int(o)        except ValueError:            return o    elif isinstance(o, dict):        return {k: self._decode(v) for k, v in o.items()}    elif isinstance(o, list):        return [self._decode(v) for v in o]    else:        return o        &gt;&gt;&gt; c = &apos;{&quot;value&quot;: &quot;42&quot;}&apos;        &gt;&gt;&gt; json.loads(c, cls=Decoder)        {&apos;value&apos;: 42}</code></pre><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://docs.python.org/3/library/json.html" target="_blank" rel="noopener">https://docs.python.org/3/library/json.html</a><br><a href="https://stackoverflow.com/questions/45068797/how-to-convert-string-int-json-into-real-int-with-json-loads" target="_blank" rel="noopener">https://stackoverflow.com/questions/45068797/how-to-convert-string-int-json-into-real-int-with-json-loads</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;环境&lt;br&gt;Python3.5.4&lt;br&gt;Pycharm 2016.3.3&lt;br&gt;Centos7&lt;/p&gt;
&lt;p&gt;在进行网络通信，或者Web开发时，经常用json作为数据交换语言，所以我们都不可避免地会涉及到json模块，以下是该模块的简单介绍。&lt;/p&gt;
&lt;p&gt;在Pychar
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>python-str、bytes、unicode区别介绍</title>
    <link href="http://yoursite.com/posts/3af5ad4e/"/>
    <id>http://yoursite.com/posts/3af5ad4e/</id>
    <published>2018-02-18T05:59:00.000Z</published>
    <updated>2018-02-18T05:59:39.731Z</updated>
    
    <content type="html"><![CDATA[<p><strong>环境</strong><br>Python3.5.4<br>Centos7</p><p>1.在Python中也存在字节型数据（bytes）和字符型数据（unicode），不过这两者在Python2和Python3中却有点不同。<br><strong>Py2 和 Py3 都用 str 类型来表示字符串</strong>，不过在Py2中，str跟bytes是等价的；在Py3中，str跟unicode是等价的。另外，值得注意的是，在Py2中，bytes跟unicode是等价的；在Py3中则是不等的。详情见下图或者在Python命令行尝试。</p><p>Python2<br><img src="http://p3d1icyx2.bkt.clouddn.com/f32f788d171e857e407e5268b1fd7255.png" alt=""></p><p>Python3<br><img src="http://p3d1icyx2.bkt.clouddn.com/baba273ed6719629b7093c3d08b82bd6.png" alt=""></p><p>2.除此之外，根据博主本人的理解，字节型转换为字符型可以理解为解码（decode），反之则是编码（encode）。<strong>下面只展示Python3的情况</strong><br>首先，我们可以通过 locale 来查看本机的默认编码方式，貌似Linux默认是utf-8，windows默认是gbk。</p><blockquote><p>>&gt;&gt;import locale<br>>&gt;&gt;locale.getpreferredencoding(False)</p></blockquote><p>其次，我们将尝试 字符-&gt;字节</p><blockquote><p>>&gt;&gt;a = ‘学习’<br>>&gt;&gt;ae = a.encode(‘utf-8’)<br>b’\xe5\xad\xa6\xe4\xb9\xa0’</p></blockquote><p>字节-&gt;字符</p><blockquote><p>>&gt;&gt; ae.decode(‘utf-8’)<br>‘学习’</p></blockquote><p>最后，因为在Py3中，字符串与unicode是等价的，所以字符串是没有decode方法的，如果调用该方法则会报错</p><blockquote><p>>&gt;&gt; a.decode(‘utf-8’)<br>Traceback (most recent call last):<br>  File “<stdin>“, line 1, in <module><br>AttributeError: ‘str’ object has no attribute ‘decode’</module></stdin></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;环境&lt;/strong&gt;&lt;br&gt;Python3.5.4&lt;br&gt;Centos7&lt;/p&gt;
&lt;p&gt;1.在Python中也存在字节型数据（bytes）和字符型数据（unicode），不过这两者在Python2和Python3中却有点不同。&lt;br&gt;&lt;strong&gt;Py2
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Pycharm 自定义模板</title>
    <link href="http://yoursite.com/posts/c2547b03/"/>
    <id>http://yoursite.com/posts/c2547b03/</id>
    <published>2018-02-01T09:38:00.000Z</published>
    <updated>2018-02-01T15:00:36.889Z</updated>
    
    <content type="html"><![CDATA[<h5 id="Pycharm-设置位置："><a href="#Pycharm-设置位置：" class="headerlink" title="Pycharm 设置位置："></a>Pycharm 设置位置：</h5><p>File-&gt;settings-&gt;Editor-&gt;File and Code Templates-&gt;Python Script</p><h5 id="模板："><a href="#模板：" class="headerlink" title="模板："></a>模板：</h5><p>#!/usr/bin/env python<br># -<em>- coding: utf-8 -</em>-<br># @Time    : ${DATE} ${TIME}<br># @Author  : Aries<br># @Site    : ${SITE}<br># @File    : ${NAME}.py<br># @Software: ${PRODUCT_NAME}</p><h5 id="可用的预定义文件模板变量："><a href="#可用的预定义文件模板变量：" class="headerlink" title="可用的预定义文件模板变量："></a>可用的预定义文件模板变量：</h5><p>$ {PROJECT_NAME} - 当前项目的名称。<br>$ {NAME} - 在文件创建过程中在“新建文件”对话框中指定的新文件的名称。<br>$ {USER} - 当前用户的登录名。<br>$ {DATE} - 当前的系统日期。<br>$ {TIME} - 当前系统时间。<br>$ {YEAR} - 今年。<br>$ {MONTH} - 当月。<br>$ {DAY} - 当月的当天。<br>$ {HOUR} - 目前的小时。<br>$ {MINUTE} - 当前分钟。<br>$ {PRODUCT_NAME} - 将在其中创建文件的IDE的名称。<br>$ {MONTH_NAME_SHORT} - 月份名称的前3个字母。 示例：1月，2月等<br>$ {MONTH_NAME_FULL} - 一个月的全名。 示例：1月，2月等</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><p><a href="https://www.cnblogs.com/mat-wu/p/7130358.html" target="_blank" rel="noopener">https://www.cnblogs.com/mat-wu/p/7130358.html</a><br><a href="https://www.cnblogs.com/ajmd/p/6239146.html" target="_blank" rel="noopener">https://www.cnblogs.com/ajmd/p/6239146.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;Pycharm-设置位置：&quot;&gt;&lt;a href=&quot;#Pycharm-设置位置：&quot; class=&quot;headerlink&quot; title=&quot;Pycharm 设置位置：&quot;&gt;&lt;/a&gt;Pycharm 设置位置：&lt;/h5&gt;&lt;p&gt;File-&amp;gt;settings-&amp;gt;Edit
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Nginx的简单介绍</title>
    <link href="http://yoursite.com/posts/d7e5ae52/"/>
    <id>http://yoursite.com/posts/d7e5ae52/</id>
    <published>2018-02-01T09:34:00.000Z</published>
    <updated>2018-02-01T15:00:36.887Z</updated>
    
    <content type="html"><![CDATA[<h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p>Centos7<br>Nginx  1.12.2</p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>nginx [engine x]是最初由Igor Sysoev编写的HTTP和反向代理服务器，邮件代理服务器和通用TCP / UDP代理服务器。</p><h4 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h4><p><a href="http://www.linuxidc.com/Linux/2017-04/142986.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2017-04/142986.htm</a><br><a href="http://nginx.org/en/docs/beginners_guide.html" target="_blank" rel="noopener">http://nginx.org/en/docs/beginners_guide.html</a></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><blockquote><p>wget <a href="http://dl.Fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm" target="_blank" rel="noopener">http://dl.Fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm</a><br>sudo rpm -ivh epel-release-latest-7.noarch.rpm<br>sudo yum install nginx -y</p></blockquote><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><ol><li>输入 systemctl start nginx 启动 nginx</li><li>在浏览器输入 nginx 服务器的IP 地址，一般为 localhost，出现此页面即安装成功</li></ol><p><img src="http://hdoc.scau.edu.cn/Public/Uploads/2018-01-24/5a686ed675f09.jpg" alt=""></p><h4 id="nginx-常用命令"><a href="#nginx-常用命令" class="headerlink" title="nginx 常用命令"></a>nginx 常用命令</h4><p>(其中 -s 是 signal 的缩写，意思是 nginx 可以通过 quit、stop 这些信号来控制 nginx )</p><blockquote><p>启动：<br>systemctl start nginx<br>sudo nginx<br>&ensp;<br>重启： systemctl restart nginx<br>&ensp;<br>停止：<br>systemctl stop nginx<br>sudo nginx -s quit(优雅地关机)<br>sudo nginx -s stop(快速关机)<br>&ensp;<br>检查状态： systemctl status nginx<br>&ensp;<br>开机自启： systemctl enable nginx<br>&ensp;<br>重新加载配置文件：sudo nginx -s reload</p></blockquote><h4 id="nginx-的权限问题"><a href="#nginx-的权限问题" class="headerlink" title="nginx 的权限问题"></a>nginx 的权限问题</h4><ol><li>本文所安装的 nginx 是由 root 安装的（sudo），所以在执行nginx命令的时候需要系统服务管理指令 systemctl 来执行，否则就很容易报权限不足的错误。</li><li>由于Centos7默认开启 SELinux 服务，这个服务对权限的把控很严格，所以需要先把它关了，这是报权限不足的主要原因。</li></ol><h4 id="nginx-配置文件及目录说明"><a href="#nginx-配置文件及目录说明" class="headerlink" title="nginx 配置文件及目录说明"></a>nginx 配置文件及目录说明</h4><p>注：通过输入 rpm -ql nginx  便可查看安装nginx 所生成的文件</p><ol><li><p>/etc/nginx/nginx.conf： nginx 配置主文件，默认情况下，该配置文件被命名nginx.conf ，并放入目录 /usr/local/nginx/conf， /etc/nginx或 /usr/local/etc/nginx。</p></li><li><p>/etc/nginx/nginx.conf.default :  关于nginx 如何配置的参考文件</p></li><li><p>/etc/nginx/conf.d  和  /etc/nginx/default.d：这两个的共同作用是 放置模块化配置文件，但什么是模块化配置文件呢？就是当你要配置的server 或者 location 比较多的时候，如果全部都放在 nginx.conf 这份文件的话，就会显得很臃肿，这时就可以把这些配置文件放在这两个目录，再通过include命令包含进来，那他们的区别在哪呢？ 在 nginx.conf 这份配置文件中，字段是分为几个级别的，其中 main &gt; events、http；而 http &gt; server &gt; location，由图可得，第一个include （conf.d）与server 是同级别的，第二个 include （default.d）是与location 同级别的，所以在 conf.d 存放server， 在default.d存放 location ，这就是它们的区别。<br><img src="http://hdoc.scau.edu.cn/Public/Uploads/2018-01-24/5a6883d20204b.png" alt=""></p></li><li><p>/usr/share/nginx/html/index.html ： 上图启动页面的HTML文件，是 index.html 的默认存放位置</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h4&gt;&lt;p&gt;Centos7&lt;br&gt;Nginx  1.12.2&lt;/p&gt;
&lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Android-Studio版本更新</title>
    <link href="http://yoursite.com/posts/63e75df2/"/>
    <id>http://yoursite.com/posts/63e75df2/</id>
    <published>2018-02-01T08:54:00.000Z</published>
    <updated>2018-02-01T09:02:47.758Z</updated>
    
    <content type="html"><![CDATA[<p>1 环境<br>旧环境：win10 64bit Android Studio1.5 gradle1.5.0 API23<br>新环境：win10 64bit Android Studio3.0 gradle3.0.0 API23</p><p>2 Android Studio 3.0 简介<br><a href="http://blog.csdn.net/tz_zs/article/details/72728179" target="_blank" rel="noopener">http://blog.csdn.net/tz_zs/article/details/72728179</a></p><p>3 下载<br><a href="http://blog.csdn.net/DickyQie/article/details/78136337" target="_blank" rel="noopener">http://blog.csdn.net/DickyQie/article/details/78136337</a> （推荐）<br><a href="https://developer.android.google.cn/studio/preview/index.html" target="_blank" rel="noopener">https://developer.android.google.cn/studio/preview/index.html</a></p><p>4 安装（已安装其他版本/无安装其他版本）<br><a href="http://www.jianshu.com/p/fbac2dbd81bc" target="_blank" rel="noopener">http://www.jianshu.com/p/fbac2dbd81bc</a></p><p> <br>AS3.0 主要亮点是支持Kotlin，以下是Kotlin的相关内容:</p><p><a href="http://blog.jobbole.com/111249/" target="_blank" rel="noopener">谷歌大牛说：为什么 Kotlin 比你们用的那些垃圾语言都好</a></p><p><a href="http://blog.csdn.net/qq_23547831/article/details/52857346" target="_blank" rel="noopener">Android Studio配置Kotlin开发环境</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1 环境&lt;br&gt;旧环境：win10 64bit Android Studio1.5 gradle1.5.0 API23&lt;br&gt;新环境：win10 64bit Android Studio3.0 gradle3.0.0 API23&lt;/p&gt;
&lt;p&gt;2 Android Studi
      
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>导入Ghost-Android工程</title>
    <link href="http://yoursite.com/posts/6b9a598/"/>
    <id>http://yoursite.com/posts/6b9a598/</id>
    <published>2018-02-01T08:53:00.000Z</published>
    <updated>2018-02-01T09:02:47.761Z</updated>
    
    <content type="html"><![CDATA[<h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p>&ensp;&ensp;导入Ghost-Android工程后，相关的 依赖包/插件 一直没有下载成功，反复重启AS+通宵下载 后，发现可能是[ ‘com.crashlytics.sdk.android:answers:1.3.7@aar’] 这个包下载不成功导致其他包也下载不成功。 <strong>将这个依赖注释后</strong>重新下载，<strong>其他包下载成功</strong>！</p><p>&ensp;&ensp;虽然将这个依赖注释后重新下载，其他包能下载成功，但还是没办法运行Ghost-Android工程，<strong>最后尝试取消注释，重新下载，居然成功了</strong>，猜想是代理不稳定导致的。</p><h5 id="Ghost-Android-github地址"><a href="#Ghost-Android-github地址" class="headerlink" title="Ghost-Android github地址"></a>Ghost-Android github地址</h5><p><a href="https://github.com/TryGhost/Ghost-Android" target="_blank" rel="noopener">https://github.com/TryGhost/Ghost-Android</a></p><h5 id="查看下载的依赖包"><a href="#查看下载的依赖包" class="headerlink" title="查看下载的依赖包"></a>查看下载的依赖包</h5><blockquote><p>C:\Users\hongxin.gradle\caches\modules-2\files-2.1 (我的路径)</p></blockquote><h5 id="aar-和-transitive-true-的含义"><a href="#aar-和-transitive-true-的含义" class="headerlink" title="@aar 和 transitive = true 的含义"></a>@aar 和 transitive = true 的含义</h5><p><a href="https://stackoverflow.com/questions/44902339/whats-the-meaning-of-aar-with-transitive-true" target="_blank" rel="noopener">https://stackoverflow.com/questions/44902339/whats-the-meaning-of-aar-with-transitive-true</a></p><h5 id="一文读懂Gradle"><a href="#一文读懂Gradle" class="headerlink" title="一文读懂Gradle"></a>一文读懂Gradle</h5><p><a href="http://android.walfud.com/tag/android/" target="_blank" rel="noopener">http://android.walfud.com/tag/android/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h5&gt;&lt;p&gt;&amp;ensp;&amp;ensp;导入Ghost-Android工程后，相关的 依赖包/插件 一直没有下载成功，反复重启AS+通宵下载 后，发现可能是
      
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>搭建个人博客(三)-Atom编辑器+七牛云图床</title>
    <link href="http://yoursite.com/posts/63e92f23/"/>
    <id>http://yoursite.com/posts/63e92f23/</id>
    <published>2018-02-01T08:45:15.000Z</published>
    <updated>2018-02-10T14:33:01.497Z</updated>
    
    <content type="html"><![CDATA[<p>背景：<br>本篇文章主要讲述的是采用 Hexo+Github+Next 框架搭建个人博客后，图床和编辑器的选择及相关介绍。<br>为什么要选择编辑器呢？当然是为了提高博客的访问速度。图床的选择其实比较简单，因为网上大多数人都推荐七牛云，主要是它有10GB免费存储空间等福利<br>为什么要选择编辑器呢？当然是为了节省时间。如果没有合适的编辑器，则每次写博客都要先上传图片到七牛云，再一个个地复制图片链接到文章中，这显然浪费了很多时间。经过层层筛选，博主最终选择了 Atom 这个编辑器，通过下载几个插件，就可以实现边写文字边上传图片的功能了，岂不乐哉！</p><p>以下主要是关于 Atom 的介绍：</p><h5 id="1-在Atom下配置七牛云作为图床"><a href="#1-在Atom下配置七牛云作为图床" class="headerlink" title="1.在Atom下配置七牛云作为图床"></a>1.在Atom下配置七牛云作为图床</h5><p>参考<br><a href="http://blog.csdn.net/shunxiangl/article/details/75944126" target="_blank" rel="noopener">http://blog.csdn.net/shunxiangl/article/details/75944126</a><br><a href="http://blog.csdn.net/qq_31915279/article/details/61824114" target="_blank" rel="noopener">http://blog.csdn.net/qq_31915279/article/details/61824114</a></p><p>注：<br>1.1 博主因为配置了代理，所以下载插件时不会出现下载不成功的情况。<br>1.2 要想上传图片到七牛云，必须绑定你自己的域名或者用<br>七牛云的测试域名，如果用七牛云的测试域名，则新建的存储空间必须是公开的。<br>1.3 要想实现上传图片，必须先截图，再Ctrl+C，Ctrl+V，而不能单纯复制粘贴你下载好的图片。</p><h5 id="2-Atom-汉化-http-blog-csdn-net-u013366098-article-details-50568779"><a href="#2-Atom-汉化-http-blog-csdn-net-u013366098-article-details-50568779" class="headerlink" title="2.Atom 汉化 http://blog.csdn.net/u013366098/article/details/50568779"></a>2.Atom 汉化 <a href="http://blog.csdn.net/u013366098/article/details/50568779" target="_blank" rel="noopener">http://blog.csdn.net/u013366098/article/details/50568779</a></h5><h5 id="3-Atom-与-Hexo-的结合"><a href="#3-Atom-与-Hexo-的结合" class="headerlink" title="3.Atom 与 Hexo 的结合"></a>3.Atom 与 Hexo 的结合</h5><p>再一次体验到 Atom 的强大之处，因为它竟然支持 Hexo 等框架，只需下载 markdown-writer 插件就可实现与 Hexo 的对接，再一次节省了写博客的时间！<br>参考教程：<a href="http://blog.csdn.net/u010494080/article/details/53562939" target="_blank" rel="noopener">http://blog.csdn.net/u010494080/article/details/53562939</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;背景：&lt;br&gt;本篇文章主要讲述的是采用 Hexo+Github+Next 框架搭建个人博客后，图床和编辑器的选择及相关介绍。&lt;br&gt;为什么要选择编辑器呢？当然是为了提高博客的访问速度。图床的选择其实比较简单，因为网上大多数人都推荐七牛云，主要是它有10GB免费存储空间等福利
      
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="Next" scheme="http://yoursite.com/tags/Next/"/>
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Linux-后台运行Python程序</title>
    <link href="http://yoursite.com/posts/d2553b91/"/>
    <id>http://yoursite.com/posts/d2553b91/</id>
    <published>2018-01-13T07:30:55.000Z</published>
    <updated>2018-02-01T08:48:08.974Z</updated>
    
    <content type="html"><![CDATA[<p>方式一：nohup 命令</p><p>该命令会在后台执行 main.py 这个程序，并将输出结果保存到 nohup.out 文件</p><blockquote><p>nohup python main.py &amp;</p></blockquote><p>将输出结果更改到 filename.out 文件。</p><blockquote><p>nohup python main.py &gt;filename.out 2&gt;&amp;1 &amp;</p></blockquote><p>查看后台运行的任务</p><blockquote><p>jobs</p></blockquote><p>nohup命令解释<br><a href="https://www.cnblogs.com/zq-inlook/p/3577003.html" target="_blank" rel="noopener">https://www.cnblogs.com/zq-inlook/p/3577003.html</a></p><p>方式二：<br><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;方式一：nohup 命令&lt;/p&gt;
&lt;p&gt;该命令会在后台执行 main.py 这个程序，并将输出结果保存到 nohup.out 文件&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;nohup python main.py &amp;amp;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将输出
      
    
    </summary>
    
      <category term="Liunx" scheme="http://yoursite.com/categories/Liunx/"/>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu16.04安装virtualbox</title>
    <link href="http://yoursite.com/posts/704f0bbb/"/>
    <id>http://yoursite.com/posts/704f0bbb/</id>
    <published>2018-01-13T07:29:51.000Z</published>
    <updated>2018-01-13T07:33:13.583Z</updated>
    
    <content type="html"><![CDATA[<p>1.virtualbox版本：virtualbox-5.1_5.1.4-110228-Ubuntu-xenial_amd64.deb</p><p>2.virtualbox安装文档地址：<a href="https://www.virtualbox.org/manual/UserManual.html" target="_blank" rel="noopener">https://www.virtualbox.org/manual/UserManual.html</a></p><p>3.安装<br><img src="http://hdoc.scau.edu.cn/Public/Uploads/2017-08-20/59996545b2a2b.png" alt=""></p><p>4.报错：vboxdrv 构建失败<br>vboxdrv介绍：为了在主操作系统旁边的虚拟机中运行其他操作系统，VirtualBox需要非常紧密地集成到系统中。要做到这一点，它会安装一个名为“驱动程序”的模块vboxdrv，该模块在系统内核中进行大量工作，这是控制处理器和物理硬件的操作系统的一部分。没有这个内核模块，你仍然可以使用VirtualBox管理器来配置虚拟机，但是它们不会启动。它还安装了调用的网络驱动程序 vboxnetflt， vboxnetadp哪些虚拟机可以更好地利用计算机的网络功能，而且超出基本“NAT”模式的虚拟机网络需要。</p><p>在执行 sudo dpkg -i virtualbox-5.1_5.1.4-110228-Ubuntu-xenial_amd64.deb<br>这条命令时，安装程序将尝试构建适合当前运行的内核的内核模块。如果构建过程不成功，您将看到一个警告，该包将被取消配置</p><p>解决步骤：（不要盲目执行本教程代码，建议阅读全文后再考虑如何执行）<br>1.查看有没有安装正确的头文件<br>查看内核版本：<br><img src="http://hdoc.scau.edu.cn/Public/Uploads/2017-08-20/5999696c4fd2b.png" alt=""></p><p>对于Debian和基于Ubuntu的发行版，您必须安装 linux-headers，通常取的linux-headers-generic ，linux-headers-amd64 ，linux-headers-i686 或linux-headers-i686-pae 这些头文件的正确版，版本名最好与内核版本名称相匹配; </p><p>头文件一般放在/usr/src 目录下<br><img src="http://hdoc.scau.edu.cn/Public/Uploads/2017-08-20/59996aeedfd4a.png" alt=""><br>如图，该头文件已正确安装（我是自动安装的），如果相应的头文件没安装，可参考下面的教程：<br><a href="https://linux.cn/article-4625-1.html#3_1245" target="_blank" rel="noopener">https://linux.cn/article-4625-1.html#3_1245</a></p><p>2.查看/var/log/vbox-install.log为什么编译失败<br><img src="http://hdoc.scau.edu.cn/Public/Uploads/2017-08-21/599af3cbdf74a.png" alt=""></p><p>通过Google和百度，网上大部分资料都指向“内核没编译”，但是因为对内核不熟，所以没敢尝试，也建议不要随便编译内核，以下是我查找的资料<br>报错解决办法：<br><a href="http://hanjiangduqiao.blog.163.com/blog/static/613105442012320558430/" target="_blank" rel="noopener">http://hanjiangduqiao.blog.163.com/blog/static/613105442012320558430/</a><br><a href="http://blog.csdn.net/chenbang110/article/details/7795011" target="_blank" rel="noopener">http://blog.csdn.net/chenbang110/article/details/7795011</a> （就是这个教程说内核没编译）<br><a href="http://www.linuxdiyf.com/viewarticle.php?id=314763" target="_blank" rel="noopener">http://www.linuxdiyf.com/viewarticle.php?id=314763</a> (这个教程说要进入 /usr/src/kernels/linux-3.6.2 目录，但是我发现我电脑并没有kernels这个目录，所以没尝试)</p><p>内核编译：<br><a href="https://kernelnewbies.org/FAQ/KernelCompilation" target="_blank" rel="noopener">https://kernelnewbies.org/FAQ/KernelCompilation</a><br><a href="http://www.linuxprobe.com/linux-kernel-compilation.html" target="_blank" rel="noopener">http://www.linuxprobe.com/linux-kernel-compilation.html</a><br><a href="http://www.cnblogs.com/super119/archive/2011/01/03/1924408.html" target="_blank" rel="noopener">http://www.cnblogs.com/super119/archive/2011/01/03/1924408.html</a><br>看起来比较有用的<br><a href="http://forum.ubuntu.org.cn/viewtopic.php?t=42690" target="_blank" rel="noopener">http://forum.ubuntu.org.cn/viewtopic.php?t=42690</a></p><p>3.安装Qt 5.3.2以上（推荐Qt 5.6.2以上）和 SDL 1.2.7或更高版本（此图形库通常称为 libsdl或类似）<br>突然在官网教程发现要安装这两个包，但是我并没有，这个对系统影响较小，所以先试试这个。<br><img src="http://hdoc.scau.edu.cn/Public/Uploads/2017-08-21/599b000bb68de.png" alt=""></p><p>查看qt版本：qmake -v<br>但有时候安装完成执行此命令还是报错<br><img src="http://hdoc.scau.edu.cn/Public/Uploads/2017-08-21/599afdf2b46dd.png" alt=""><br>解决办法：<a href="http://blog.csdn.net/zhuquan945/article/details/52818786" target="_blank" rel="noopener">http://blog.csdn.net/zhuquan945/article/details/52818786</a></p><p>qt5.7安装教程<br><a href="https://qtguide.ustclug.org/ch01-04.htm" target="_blank" rel="noopener">https://qtguide.ustclug.org/ch01-04.htm</a><br><a href="http://blog.csdn.net/u012235003/article/details/71195046" target="_blank" rel="noopener">http://blog.csdn.net/u012235003/article/details/71195046</a> （我用这个安装）</p><blockquote><p>下载包：<br>wget <a href="http://download.qt.io/official_releases/qt/5.7/5.7.0/qt-opensource-linux-x64-5.7.0.run" target="_blank" rel="noopener">http://download.qt.io/official_releases/qt/5.7/5.7.0/qt-opensource-linux-x64-5.7.0.run</a><br>下载后给执行权限:  chmod +x qtxxxx.run<br>安装 :       ./qtxxxx.run<br>安装g++:   sudo apt-get install build-essential<br>安装依赖库: sudo apt-get install libfontconfig1<br>安装OpenGL: sudo apt-get install mesa-common-dev<br>以及依赖: sudo apt-get install libglu1-mesa-dev -y<br>配置:  打开qt creator 工具-&gt;选项-&gt;构建&amp;运行-&gt;编译，选择编译器</p></blockquote><p>SDL安装<br>SDL1.0安装：<a href="http://www.linuxidc.com/Linux/2010-07/26965.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2010-07/26965.htm</a><br>SDL2.0安装：<a href="http://wiki.libsdl.org/Installation" target="_blank" rel="noopener">http://wiki.libsdl.org/Installation</a></p><p>痛心：安装qt5和SDL后还是报错<br><img src="http://hdoc.scau.edu.cn/Public/Uploads/2017-08-21/599b006c28aeb.png" alt=""></p><p>4.重新Google报错原因<br><a href="http://blog.csdn.net/jingtiangao/article/details/51811638" target="_blank" rel="noopener">http://blog.csdn.net/jingtiangao/article/details/51811638</a><br><a href="https://askubuntu.com/questions/762254/why-do-i-get-required-key-not-available-when-install-3rd-party-kernel-modules" target="_blank" rel="noopener">https://askubuntu.com/questions/762254/why-do-i-get-required-key-not-available-when-install-3rd-party-kernel-modules</a>  （这一篇的第二个答案（点赞量14）之前试过，曾经能启动，但后来又不行了）</p><p>根本原因：从内核版本4.4.0-20开始，如果启用了UEFI Secure Boot，强制执行未启用安全启动的未签名内核模块将不允许运行<br>解决办法：在BIOS里面关闭安全启动在执行 sudo rcvboxdrv setup 重新编译<br><img src="http://hdoc.scau.edu.cn/Public/Uploads/2017-08-22/599b08c599be4.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.virtualbox版本：virtualbox-5.1_5.1.4-110228-Ubuntu-xenial_amd64.deb&lt;/p&gt;
&lt;p&gt;2.virtualbox安装文档地址：&lt;a href=&quot;https://www.virtualbox.org/manual/U
      
    
    </summary>
    
      <category term="Liunx" scheme="http://yoursite.com/categories/Liunx/"/>
    
    
  </entry>
  
  <entry>
    <title>搭建个人博客(二)- Next主题配置</title>
    <link href="http://yoursite.com/posts/7879e99d/"/>
    <id>http://yoursite.com/posts/7879e99d/</id>
    <published>2018-01-13T07:27:15.000Z</published>
    <updated>2018-02-01T08:45:59.044Z</updated>
    
    <content type="html"><![CDATA[<p>本文是上一篇文章 “ Hexo+Github+Next 搭建个人博客(一)”的延续，主要讲述自己在配置 Next 主题时遇到的一些问题，是已经假设你已经搭好环境的情况下，如果对环境搭建还有不懂的地方，请看上一篇文章哦。</p><h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><p><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">http://theme-next.iissnan.com/getting-started.html</a><br><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/index.html</a></p><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><h5 id="1-添加栏目"><a href="#1-添加栏目" class="headerlink" title="1.添加栏目"></a>1.添加栏目</h5><p>如下图， 在添加栏目时需定义路径和图标，图标既可在 menu 这里定义 (符号|| 后面就是图标的名称 )也可以在 menu_icons 定义。该图标是到 <a href="http://fontawesome.io/icons/" target="_blank" rel="noopener">http://fontawesome.io/icons/</a> 这个网站找的。<br><img src="http://hdoc.scau.edu.cn/Public/Uploads/2018-01-13/5a599561675f8.png" alt=""></p><h5 id="2-添加社交链接"><a href="#2-添加社交链接" class="headerlink" title="2.添加社交链接"></a>2.添加社交链接</h5><p>一般情况下在 Next 的配置文件是不会定义中文字体的，中文字体都是定义在 /languages/zh-Hans.yml 文件下，但是我在 /languages/zh-Hans.yml  定义后，还是不会显示“简书”，“知乎”的中文，最后是直接在 配置文件 定义才行，如下图。</p><p><img src="http://hdoc.scau.edu.cn/Public/Uploads/2018-01-13/5a5998ab9c0d6.png" alt=""></p><p>一般情况下，配置到这里，整个博客的样子也应该出来了，但问题总是有的…</p><h5 id="3-点击-”关于“-显示-”Cannot-GET-about-“"><a href="#3-点击-”关于“-显示-”Cannot-GET-about-“" class="headerlink" title="3.点击 ”关于“ 显示 ”Cannot GET /about/“"></a>3.点击 ”关于“ 显示 ”Cannot GET /about/“</h5><p>这是因为你没有新建页面（page）的缘故，需键入下面命令，键入后在source文件夹下会对应生成 “about” 文件夹 和 index.md 文件，index.md 便是你显示的页面了。之后你便可以肆无忌惮的写文章了。</p><blockquote><p>hexo new page about</p></blockquote><h5 id="4-显示分类的效果，如下图"><a href="#4-显示分类的效果，如下图" class="headerlink" title="4.显示分类的效果，如下图"></a>4.显示分类的效果，如下图</h5><p><img src="http://hdoc.scau.edu.cn/Public/Uploads/2018-01-13/5a59a09655dee.png" alt=""></p><p>该效果需要以下三个步骤：</p><blockquote><p># 1.新建页面<br>hexo new page categories<br>&ensp;<br> # 2.添加 type 和 comments<br>-–<br>title: 分类<br>date: 2018-01-13 11:12:25<br>type: “categories”<br>comments: false<br>-–<br>&ensp;<br>3.在文章添加分类<br><img src="http://hdoc.scau.edu.cn/Public/Uploads/2018-01-13/5a59a047dfc42.png" alt=""></p></blockquote><h5 id="5-部署-Hexo-时设置免密码，节省时间"><a href="#5-部署-Hexo-时设置免密码，节省时间" class="headerlink" title="5.部署 Hexo 时设置免密码，节省时间"></a>5.部署 Hexo 时设置免密码，节省时间</h5><p><a href="https://segmentfault.com/a/1190000005125610" target="_blank" rel="noopener">设置 SSH 使用 hexo deploy 时免输用户名密码</a></p><h5 id="6-安装-HexoEditor"><a href="#6-安装-HexoEditor" class="headerlink" title="6.安装 HexoEditor"></a>6.安装 HexoEditor</h5><p>官方地址：<a href="https://github.com/zhuzhuyule/HexoEditor/blob/master/doc/en/Building.md" target="_blank" rel="noopener">https://github.com/zhuzhuyule/HexoEditor/blob/master/doc/en/Building.md</a><br>淘宝镜像： <a href="https://npm.taobao.org/" target="_blank" rel="noopener">https://npm.taobao.org/</a></p><blockquote><p># If In China China China, you can set mirror to speed up !<br>npm config set registry “<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a>“<br>npm config set electron_mirror “<a href="https://npm.taobao.org/mirrors/electron/" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/electron/</a>“</p><p># 克隆项目<br>git clone <a href="https://github.com/zhuzhuyule/HexoEditor.git" target="_blank" rel="noopener">https://github.com/zhuzhuyule/HexoEditor.git</a></p><p># 使用淘宝定制cnpm， 用npm下载总会出错<br>sudo npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p><p>cd HexoEditor<br>sudo cnpm install<br>sudo cnpm start</p></blockquote><h5 id="7-更换Google字体"><a href="#7-更换Google字体" class="headerlink" title="7.更换Google字体"></a>7.更换Google字体</h5><p>更换Google字体主要是它影响了站点的访问速度，对于这个问题，有几种解决办法：</p><ul><li><a href="https://www.jianshu.com/p/fdbb9aa536bd" target="_blank" rel="noopener">换国内源，比如使用 360 CDN Google 字体库(貌似挂了)、科大 CDN Google 字体库(懒人推荐)</a></li><li><a href="http://stonebythesea.org/2017/03/05/%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0-Google-Fonts%EF%BC%8C%E5%8D%9A%E5%AE%A2%E6%B5%8F%E8%A7%88%E9%80%9F%E5%BA%A6%E6%AD%A3%E5%B8%B8%E4%BA%86/" target="_blank" rel="noopener">使用本地 Google Fonts</a></li></ul><h5 id="8-字数，阅读时长统计"><a href="#8-字数，阅读时长统计" class="headerlink" title="8.字数，阅读时长统计"></a>8.字数，阅读时长统计</h5><p><a href="http://www.joryhe.com/2016-06-06-hexo_wordcount_setting_your_post.html" target="_blank" rel="noopener">hexo-wordcount实现文章标题栏显示更多的文章信息</a></p><h5 id="9-进阶教程"><a href="#9-进阶教程" class="headerlink" title="9.进阶教程"></a>9.进阶教程</h5><p><a href="http://muyunyun.cn/posts/f55182c5/#more" target="_blank" rel="noopener">hexo 摸爬滚打之进阶教程</a><br><a href="http://blog.ynxiu.com/2016/hexo-next-theme-optimize.html" target="_blank" rel="noopener">Hexo+NexT主题配置备忘</a><br><a href="http://www.joryhe.com/2016-06-05-hexo_site_seo_speed_more_optimization.html#" target="_blank" rel="noopener">Hexo博客优化，如何加快你的博客访问速度(精)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文是上一篇文章 “ Hexo+Github+Next 搭建个人博客(一)”的延续，主要讲述自己在配置 Next 主题时遇到的一些问题，是已经假设你已经搭好环境的情况下，如果对环境搭建还有不懂的地方，请看上一篇文章哦。&lt;/p&gt;
&lt;h4 id=&quot;文档&quot;&gt;&lt;a href=&quot;#文
      
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="Next" scheme="http://yoursite.com/tags/Next/"/>
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>搭建个人博客(一)-框架选择及小尝试</title>
    <link href="http://yoursite.com/posts/e170b827/"/>
    <id>http://yoursite.com/posts/e170b827/</id>
    <published>2018-01-13T07:27:07.000Z</published>
    <updated>2018-02-01T09:03:41.657Z</updated>
    
    <content type="html"><![CDATA[<h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p>Centos7</p><h4 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h4><p> <a href="https://mritd.me/2015/12/31/Github-%E6%90%AD%E5%BB%BA-Hexo-%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">Github 搭建 Hexo 静态博客</a></p><p>上面的教程采用的是  Hexo + Github + Yilia 主题，但本人在采用 Yilia 主题出现了一点问题，所以最后采用的是 Next 主题。以下是自己遇到的一些问题及解决办法</p><h4 id="Hexo-框架"><a href="#Hexo-框架" class="headerlink" title="Hexo 框架"></a>Hexo 框架</h4><p><strong>1.在/etc/profle 配置了node.js 的路径，用“sudo npm install …” 提示 “sudo npm  找不到命令“</strong></p><p>原因：当 sudo以管理权限执行命令的时候，Linux将PATH环境变量进行了重置，当然这主要是因为系统安全的考虑,所以会找不到该路径。</p><p>解决办法（路径要更改为自己的）：</p><blockquote><p>sudo ln -s /usr/local/node-v8.9.3/bin/node /usr/bin/node<br>sudo ln -s /usr/local/node-v8.9.3/lib/node_modules /usr/lib/node<br>sudo ln -s /usr/local/node-v8.9.3/bin/npm /usr/bin/npm</p></blockquote><p>参考： <a href="https://www.cnblogs.com/ishell/p/4333763.html" target="_blank" rel="noopener">https://www.cnblogs.com/ishell/p/4333763.html</a></p><p><strong>2.让 hexo server 后台运行</strong><br><a href="http://www.tuijiankan.com/2015/05/08/hexo-forever-run/" target="_blank" rel="noopener">http://www.tuijiankan.com/2015/05/08/hexo-forever-run/</a></p><h4 id="yilia主题"><a href="#yilia主题" class="headerlink" title="yilia主题"></a>yilia主题</h4><p>1 采用 yilia 主题的博客<br><a href="http://litten.me/" target="_blank" rel="noopener">http://litten.me/</a><br><a href="http://zbk1nger.github.io/" target="_blank" rel="noopener">http://zbk1nger.github.io/</a></p><p><strong>2 采用 yilia 主题时图片的路径问题</strong></p><p><img src="http://hdoc.scau.edu.cn/Public/Uploads/2018-01-08/5a52fd433701e.png" alt=""></p><p>如图，我在 yilia 的配置文件分别配置了三张图片：支付宝、微信的收款码和个人头像。上图的 /img 文件夹 注意是要放在 根目录下的 source 文件夹下，再通过以下这三条命令生成便可预览。</p><blockquote><p>hexo clean   # 清除缓存<br>hexo g       # 生成静态文件<br>hexo s       # 启动服务器预览</p></blockquote><p><strong>3 yilia 主题发布的文章 在主页显示时 文章的内容 会全部显示，个人觉得那样很长很难看，所以想要部分展示的效果，类似于这样</strong><br><img src="http://hdoc.scau.edu.cn/Public/Uploads/2018-01-08/5a5344eb4d699.png" alt=""></p><p>解决办法：在文章需要截断的位置加上 more 标签，如下图</p><p><img src="http://hdoc.scau.edu.cn/Public/Uploads/2018-01-08/5a534580a826c.png" alt=""></p><p>但是添加标签后出现了上图的效果，与“展开全文”重复，而且也不好看，本人没学过前端，故最后切换成 Next 主题。</p><h4 id="Next主题"><a href="#Next主题" class="headerlink" title="Next主题"></a>Next主题</h4><p>Next 主题的配置见本人的下一篇博客 “搭建个人博客(二)- Next主题配置”。</p><h4 id="其它链接"><a href="#其它链接" class="headerlink" title="其它链接"></a>其它链接</h4><p>搭建个人博客，你需要知道这些<br><a href="https://zhuanlan.zhihu.com/p/25744686" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25744686</a></p><p>好看的 Hexo 主题<br><a href="https://www.zhihu.com/question/24422335" target="_blank" rel="noopener">https://www.zhihu.com/question/24422335</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h4&gt;&lt;p&gt;Centos7&lt;/p&gt;
&lt;h4 id=&quot;参考教程&quot;&gt;&lt;a href=&quot;#参考教程&quot; class=&quot;headerlink&quot; title=&quot;参考
      
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="Next" scheme="http://yoursite.com/tags/Next/"/>
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
